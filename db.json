{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1491307011000},{"_id":"source/.DS_Store","hash":"c822beebe269da91e5dfe88f3c848df23efb4369","modified":1491307011000},{"_id":"themes/jacman/README.md","hash":"75a5c9fbd7c9cec4d2f277042d2fee550e4936be","modified":1491307011000},{"_id":"themes/jacman/README_zh.md","hash":"d6014b16eaccc97dc54a7779c9e36003752410e1","modified":1491307011000},{"_id":"themes/jacman/_config.yml","hash":"3722018434192c98ab8a7e2fc15c45d13cb0c138","modified":1491564617000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1491307011000},{"_id":"source/_posts/B-tree索引.md","hash":"ade9aa5fe9ed5b1056f963717c3107c75b15ef08","modified":1491307011000},{"_id":"source/_posts/Homeland.md","hash":"c528e41ac6dc358dda6f5cfae085f1d154775b74","modified":1491307011000},{"_id":"source/_posts/C-语言相关.md","hash":"00079c6c02903e7de62196101283d1361e64ef66","modified":1491307011000},{"_id":"source/_posts/Linux-Shell命令总结.md","hash":"1c2c4c08b45db16596b95b54407ba55f3b99980d","modified":1491307011000},{"_id":"source/_posts/Vim技巧.md","hash":"6e7308bc882cdc39bd997c684f2b82d9b4e4719e","modified":1491307011000},{"_id":"source/_posts/Paxos算法理解.md","hash":"c1af5e6b8dc89d868640a0daf33efc5f523b742c","modified":1491307011000},{"_id":"source/_posts/Words.md","hash":"5100f8c17b341dc368d89aa3d1b5b8c695092758","modified":1491307011000},{"_id":"source/_posts/Sublime-Text-2-快捷键总结.md","hash":"ccd6edabcb83e875b41886f1d09b804729af74a9","modified":1491307011000},{"_id":"source/_posts/如何使用hexo.md","hash":"d68430afc4201628ac18d3ffc8cbf73f1468beb0","modified":1491307011000},{"_id":"source/_posts/头文件中定义函数引发的multiple-definition.md","hash":"65bf107e5919fcd8e89bd444d1cf5c52e52f7e71","modified":1491307011000},{"_id":"source/_posts/数据库事务隔离级别.md","hash":"20433060a13ba2eae03cf4d6ed03acaf1e988cbe","modified":1491307011000},{"_id":"source/_posts/time-linux程序运行时间统计.md","hash":"3f7cec625ad8564a2164a4f5c4aa6993a2b22565","modified":1491307011000},{"_id":"source/_posts/自旋锁SpinLock.md","hash":"8fd2513bc0ff8d7a2e7d920c58c1d93d563e3984","modified":1491307011000},{"_id":"source/about/index.md","hash":"fd0de66509a3f97a747cfb70da1d83f1df889851","modified":1491557896000},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1491307011000},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1491307011000},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1491307011000},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1491307011000},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1491307011000},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1491307011000},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1491307011000},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1491307011000},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1491307011000},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1491307011000},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1491307011000},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1491307011000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1491307011000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1491307011000},{"_id":"themes/jacman/source/img/author.jpg","hash":"26f9931a60aeb4bd530b0f4dd62d8456418ac60c","modified":1491307011000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1491307011000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1491307011000},{"_id":"themes/jacman/source/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1491307011000},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1491307011000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1491307011000},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1491307011000},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1491307011000},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1491307011000},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1491307011000},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1491307011000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1491307011000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1491307011000},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1491307011000},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1491307011000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1491307011000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1491307011000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1491307011000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1491307011000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1491307011000},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1491307011000},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1491307011000},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"c703b0c25139b8a5f8f9d24a334a07905e2b7987","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"5f80bf6c6ddcf8c28c4599cd1540b14b25d54f18","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1491307011000},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1491307011000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1491307011000},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1491307011000},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1491307011000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1491307011000},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1491307011000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1491307011000},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1491307011000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1491307011000},{"_id":"themes/jacman/source/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1491307011000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1491307011000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1491307011000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1491307011000},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1491307011000},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1491307011000},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1491307011000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1491307011000},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1491307011000},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1491307011000},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1491307011000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1491307011000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1491307011000},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1491307011000},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1491307011000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1491307011000},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1491307011000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1491307011000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1491307011000},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1491307011000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1491307011000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1491307011000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1491307011000},{"_id":"public/about/index.html","hash":"f1bc7e5e73f6e775905f670ba3383be16fa5e8d0","modified":1491564667612},{"_id":"public/2017/04/03/Homeland/index.html","hash":"cfdac84e520c5b1669555a1b37ec920229866c16","modified":1491564667613},{"_id":"public/2017/04/03/Sublime-Text-2-快捷键总结/index.html","hash":"af8b82f33960b2aadad76ecfc77a953df46c850c","modified":1491564667614},{"_id":"public/2017/04/03/Words/index.html","hash":"6b541d3228148c744bb66ca87c1219d9c54d2592","modified":1491564667614},{"_id":"public/2017/04/03/B-tree索引/index.html","hash":"e8633c467a508b012a1af06e18f83f7ab03e17ce","modified":1491564667614},{"_id":"public/2017/04/03/如何使用hexo/index.html","hash":"625539ab002b95d19727aebf26b1102fdc1f3db6","modified":1491564667614},{"_id":"public/archives/index.html","hash":"b9224d7b835578da9d83a572a11fa63c221d17ca","modified":1491564667614},{"_id":"public/archives/page/2/index.html","hash":"9d06c3cd331d03191500cca0937faeb66d00772e","modified":1491564667614},{"_id":"public/archives/2017/index.html","hash":"e159de2b4e90b6a12663f7d4393b11fe4da956d5","modified":1491564667614},{"_id":"public/archives/2017/page/2/index.html","hash":"3f7ac7ebbc7b114825f2bad09f4d1b1c745b2b37","modified":1491564667614},{"_id":"public/archives/2017/04/index.html","hash":"ec465c69da7c7e8e9e2a84f274cdab73a69708f3","modified":1491564667614},{"_id":"public/archives/2017/04/page/2/index.html","hash":"905606853b0039ab94d466da8f798fa9dd04941c","modified":1491564667614},{"_id":"public/index.html","hash":"639156177f755740dd94dfc58c92405f594995e9","modified":1491564667614},{"_id":"public/page/2/index.html","hash":"9558eb8dfc8d333b4e850acb8763bd679f4eee59","modified":1491564667614},{"_id":"public/tags/B-tree/index.html","hash":"65c37ff89b85b0e7be1433f26c294807cc7ed33a","modified":1491564667614},{"_id":"public/tags/Linux/index.html","hash":"cf8ed55d9ed9982bbde304b44d268a5735b8c8a6","modified":1491564667614},{"_id":"public/tags/shell/index.html","hash":"bf0cbfd21d529f687954d395e6e3d28f90ce30b0","modified":1491564667614},{"_id":"public/tags/Paxos/index.html","hash":"19eec566a9ce5875fc316773bd121a33f1cc1b35","modified":1491564667615},{"_id":"public/tags/sublime-text/index.html","hash":"65877cae0eee0af73ef4bdc9322f87660c11feee","modified":1491564667615},{"_id":"public/tags/快捷键/index.html","hash":"91f192c91c901b24edde9f3a59a3ba8149481ce3","modified":1491564667615},{"_id":"public/tags/hexo/index.html","hash":"f45709d22f7005314b266883a3ac64aa8ac6de9e","modified":1491564667615},{"_id":"public/tags/C/index.html","hash":"338e26acd9cab4faec71fcf58ac2ef0e326a6fc4","modified":1491564667615},{"_id":"public/tags/隔离级别/index.html","hash":"15eefab607e1792c239f3195a1984b1f15701484","modified":1491564667615},{"_id":"public/tags/time/index.html","hash":"cc2fffba7a35c827711e32ee54540cab25b06913","modified":1491564667615},{"_id":"public/2017/04/03/数据库事务隔离级别/index.html","hash":"2c17b47132384dba1105eecb1b31c63957e20349","modified":1491564667615},{"_id":"public/2017/04/03/自旋锁SpinLock/index.html","hash":"b61f568c14a677e37e6db67cb7609903e4a21caa","modified":1491564667615},{"_id":"public/2017/04/03/C-语言相关/index.html","hash":"25795c30a9560745fdae2187ad367dd84e3b68f8","modified":1491564667615},{"_id":"public/2017/04/03/头文件中定义函数引发的multiple-definition/index.html","hash":"51f8c45ed02c8694380a7963b1399cea86c0a946","modified":1491564667615},{"_id":"public/2017/04/03/Paxos算法理解/index.html","hash":"70cde0207afd9bdb3082d610d2fd2c022419d26c","modified":1491564667616},{"_id":"public/2017/04/03/Linux-Shell命令总结/index.html","hash":"bb533966cba42412a0641484e439d5a47634669f","modified":1491564667616},{"_id":"public/2017/04/03/Vim技巧/index.html","hash":"aa08b0befcf81d113240f023ffcb2daac4e50790","modified":1491564667616},{"_id":"public/2017/04/03/time-linux程序运行时间统计/index.html","hash":"6d278134448e8c3450ebebb4f5e3d301058391e1","modified":1491564667616},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1491564667628},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1491564667628},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1491564667628},{"_id":"public/img/author.jpg","hash":"26f9931a60aeb4bd530b0f4dd62d8456418ac60c","modified":1491564667628},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1491564667628},{"_id":"public/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1491564667629},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1491564667629},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1491564667629},{"_id":"public/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1491564667629},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1491564667629},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1491564667629},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1491564667629},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1491564667629},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1491564667629},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1491564667629},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1491564667629},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1491564667629},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1491564667629},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1491564667629},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1491564667629},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1491564667629},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1491564667630},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1491564667630},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1491564667630},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1491564667630},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1491564667630},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1491564667630},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1491564667630},{"_id":"public/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1491564668368},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1491564668368},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1491564668368},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1491564668368},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1491564668372},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1491564668372},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1491564668372},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1491564668372},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1491564668372},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1491564668372},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1491564668373},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1491564668373},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1491564668373},{"_id":"public/css/style.css","hash":"3e6416f470be554bbb49f95ac624c48db7d0757f","modified":1491564668373},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1491564668373},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1491564668373},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1491564668373},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1491564668373},{"_id":"public/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1491564668374},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1491564668374}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-04-07T09:38:16.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-04-07 17:38:16\n---\n","updated":"2017-04-07T09:38:16.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj17r3ah20001pvs63wsorbcv","content":"","excerpt":"","more":""}],"Post":[{"title":"B+tree索引","date":"2017-04-03T01:58:30.000Z","_content":"\n关于B-Tree、B+Tree相关理论知识参考July的[博客](http://blog.csdn.net/v_JULY_v/article/details/6530142)；\nB+Tree在数据库索引系统中的应用参见这篇[文章](http://blog.jobbole.com/24006/)；\nB-Tree源码实现简易[示例](http://canofy.iteye.com/blog/419140)；\n","source":"_posts/B-tree索引.md","raw":"---\ntitle: B+tree索引\ndate: 2017-04-03 09:58:30\ntags: B+tree\n---\n\n关于B-Tree、B+Tree相关理论知识参考July的[博客](http://blog.csdn.net/v_JULY_v/article/details/6530142)；\nB+Tree在数据库索引系统中的应用参见这篇[文章](http://blog.jobbole.com/24006/)；\nB-Tree源码实现简易[示例](http://canofy.iteye.com/blog/419140)；\n","slug":"B-tree索引","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3agw0000pvs6uto8rgsz","content":"<p>关于B-Tree、B+Tree相关理论知识参考July的<a href=\"http://blog.csdn.net/v_JULY_v/article/details/6530142\" target=\"_blank\" rel=\"external\">博客</a>；<br>B+Tree在数据库索引系统中的应用参见这篇<a href=\"http://blog.jobbole.com/24006/\" target=\"_blank\" rel=\"external\">文章</a>；<br>B-Tree源码实现简易<a href=\"http://canofy.iteye.com/blog/419140\" target=\"_blank\" rel=\"external\">示例</a>；</p>\n","excerpt":"","more":"<p>关于B-Tree、B+Tree相关理论知识参考July的<a href=\"http://blog.csdn.net/v_JULY_v/article/details/6530142\">博客</a>；<br>B+Tree在数据库索引系统中的应用参见这篇<a href=\"http://blog.jobbole.com/24006/\">文章</a>；<br>B-Tree源码实现简易<a href=\"http://canofy.iteye.com/blog/419140\">示例</a>；</p>\n"},{"title":"Homeland","date":"2017-04-03T08:38:06.000Z","_content":"\nCarrie,\nI guess I’m done, and we never happened.  \nI’m not one for words, but they’re coming now.  \nI don’t believe in fate or destiny or horoscopes, but I can’t say I’m surprised things turned out this way. I always felt there was something kind of pulling me back to darkness. Does that make sense?  \nBut I wasn’t allowed a real life or real love. That was for normal people. With you, I thought, ah, maybe, just maybe, but I know now that was a false glimmer.  \nI’m used to those-they happen all the time in the desert-but this one got to me. And here’s the thing, this death, this end of me is exactly what should have happened. I wanted the darkness. I fucking asked for it. It has me now.  \nSo don’t put a star on the wall for me. Don’t say some dumb speech. Just think of me as a light on the headlands, a beacon, steering you clear of the rocks.  \nI loved you.  \nYours for always now.  \n-Quinn\n\n\n我不是一个善言辞的人，但是现在很多话涌上心头。\n请不要在墙上为我挂勋章，不要说一些没用的话，仅仅把我当做海角上的一道光，一座灯塔，指引你避开礁石。\n\n","source":"_posts/Homeland.md","raw":"---\ntitle: Homeland\ndate: 2017-04-03 16:38:06\ntags:\n---\n\nCarrie,\nI guess I’m done, and we never happened.  \nI’m not one for words, but they’re coming now.  \nI don’t believe in fate or destiny or horoscopes, but I can’t say I’m surprised things turned out this way. I always felt there was something kind of pulling me back to darkness. Does that make sense?  \nBut I wasn’t allowed a real life or real love. That was for normal people. With you, I thought, ah, maybe, just maybe, but I know now that was a false glimmer.  \nI’m used to those-they happen all the time in the desert-but this one got to me. And here’s the thing, this death, this end of me is exactly what should have happened. I wanted the darkness. I fucking asked for it. It has me now.  \nSo don’t put a star on the wall for me. Don’t say some dumb speech. Just think of me as a light on the headlands, a beacon, steering you clear of the rocks.  \nI loved you.  \nYours for always now.  \n-Quinn\n\n\n我不是一个善言辞的人，但是现在很多话涌上心头。\n请不要在墙上为我挂勋章，不要说一些没用的话，仅仅把我当做海角上的一道光，一座灯塔，指引你避开礁石。\n\n","slug":"Homeland","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ah90002pvs6mrl4xfrm","content":"<p>Carrie,<br>I guess I’m done, and we never happened.<br>I’m not one for words, but they’re coming now.<br>I don’t believe in fate or destiny or horoscopes, but I can’t say I’m surprised things turned out this way. I always felt there was something kind of pulling me back to darkness. Does that make sense?<br>But I wasn’t allowed a real life or real love. That was for normal people. With you, I thought, ah, maybe, just maybe, but I know now that was a false glimmer.<br>I’m used to those-they happen all the time in the desert-but this one got to me. And here’s the thing, this death, this end of me is exactly what should have happened. I wanted the darkness. I fucking asked for it. It has me now.<br>So don’t put a star on the wall for me. Don’t say some dumb speech. Just think of me as a light on the headlands, a beacon, steering you clear of the rocks.<br>I loved you.<br>Yours for always now.<br>-Quinn</p>\n<p>我不是一个善言辞的人，但是现在很多话涌上心头。<br>请不要在墙上为我挂勋章，不要说一些没用的话，仅仅把我当做海角上的一道光，一座灯塔，指引你避开礁石。</p>\n","excerpt":"","more":"<p>Carrie,<br>I guess I’m done, and we never happened.<br>I’m not one for words, but they’re coming now.<br>I don’t believe in fate or destiny or horoscopes, but I can’t say I’m surprised things turned out this way. I always felt there was something kind of pulling me back to darkness. Does that make sense?<br>But I wasn’t allowed a real life or real love. That was for normal people. With you, I thought, ah, maybe, just maybe, but I know now that was a false glimmer.<br>I’m used to those-they happen all the time in the desert-but this one got to me. And here’s the thing, this death, this end of me is exactly what should have happened. I wanted the darkness. I fucking asked for it. It has me now.<br>So don’t put a star on the wall for me. Don’t say some dumb speech. Just think of me as a light on the headlands, a beacon, steering you clear of the rocks.<br>I loved you.<br>Yours for always now.<br>-Quinn</p>\n<p>我不是一个善言辞的人，但是现在很多话涌上心头。<br>请不要在墙上为我挂勋章，不要说一些没用的话，仅仅把我当做海角上的一道光，一座灯塔，指引你避开礁石。</p>\n"},{"title":"Linux Shell命令总结","date":"2017-04-03T02:36:53.000Z","_content":"\n1. 使用find命令找到大于指定大小的文件：  \n\tfind /-type f -size +10G\n2. 在Linux下如何让文件夹下的文件让文件按大小排序？  \n\t方法一：# ls -lhSl 长格式显示，h human readable模式，大小单位为M,G等易读格式，S size按大小排序；  \n    方法二：# du -h | sort -n\n\t当然您也可以结合管道查看文件夹内最大的几个文件或最小的几个文件, 再加上管道符号和head或者tail命令即可du -h | sort -n|head du -h * | sort -n|tail\n3. 命令最后加上 & 符号表示在后台执行，shell不会阻塞；\n4. rz 在xshell中接收文件\n5. sz filename 在xshell中发送文件到windows主机\n6. sudo su #切换到root shell\n7. more /etc/issue #查看操作系统版本\n8. 查找文件：\n\tfind /path -name filename #系统内查找该文件(文件名必须是全的，不能部分匹配)  \n\tgrep xxx path/* -nr #搜索path路径下包含xxx内容的文件(只查找文件)，n表示显示行号，r表示在path子目录中递归执行  \n\tlocate filename  \n9. [sudo] kill -9 进程号 #杀死进程，前面的sudo可选\n10. ps –ef | grep 进程名 #查看包含进程名的进程，如 ps -ef | grep hive\n11. lsof –i:端口号 #查看端口号占用情况\n12. netstat –nltp | grep 进程号 #RedHat查看进程号所占用的端口号  \n\tnetstat -an | grep 端口号 #查看端口占用情况  \n13. sudo fuser 端口号/tcp #查看tcp端口占用的进程号\n14. 组合：ps -ef | grep $(fuser 端口号/tcp)\n15. netstat -anp | grep pid #ubuntu:查看进程占用端口号\n16. sudo cat /etc/group #查看用户组\n17. sudo cat /etc/passwd #查看所有用户\n18. sudo useradd xxx\n19. sudo userdel name\n20. sudo usermod -a -G groupname username\n21. sudo rpm -ivh xxx.rpm\n22. sudo rpm -e xxx\n23. sudo yum install xxx\n24. sudo yum remove xxx\n25. ln -s source/folder targetLinkName(不存在的一个名字) #注意删除软连接内容相当于删除了真实的文件\n26. du -sh /folder1/ #查看folder1目录占用的总空间\n27. du -sh /folder1/* #查看folder1目录里面各个子文件（夹）空间占用情况\n28. df -lh #查看各个文件系统空间占用情况\n29. tailf xxx.log #显示log文件最后十行内容，文件变时会自动更新，与 tail -f 命令的区别是log文件长度不变时不会自动读磁盘，故更省资源\n30. sudo chkconfig mysqld on/off #设置/关闭 开机自启动\n31. Ctrl r 进入reverse-i(incremental)-search 反向增量搜索模式，输入字母即可搜索出历史命令，按左右方向键开始编辑命令；\n32. vi - #以stdin的内容为内容编辑一个新文件\n33. grep xxx path/* -nr | vi - #即将查找到的行作为内容显示在一个新文件中，用vi打开\n34. pdsh -R ssh -g groupname “ls -l” 在配置好的无密码登陆集群执行ls命令，注意可以在双引号里执行多条命令，命令之间用分号隔开；注意执行多条命令时必须用引号括起来；\n35. pdsh -g mpp-jia tar xzf /tmp/mpp-patch.tgz -C `pwd` 以执行本命令的机器上的当前目录为目标目录（pwd命令的结果），在几个节点上解压tgz文件\n36. tar -cvf xxx.tar.gz /dir #打包dir目录\n37. tar -xvf xxx.tar.gz #解压缩\n38. bunzip2 linux-2-4-2.tar.bz2 #解压生成 .tar文件\n39. tar xvf linux-2-4-2.tar #解压 .tar文件\n40. tar jxvf linux-2-4-2.tar.bz2 #一次性解压，等价于以上两条命令\n41. cp -r /source /dest/ #将source目录复制到dest中，会在dest中自动新建一个source目录\n42. cp -r /source/ /dest/ #将source中的子目录复制到dest中\n43. env | grep hbase #查看hbase相关的环境变量配置信息\n44. . xx.sh 和 ./xx.sh 优先使用前者,因为后者会新开一个子shell，在子shell里执行，而前者是在当前shell里执行\n45. xx.sh == source xx.sh\n46. ./xx.sh == sh xx.sh == bash xx.sh\n47. rpm -qlp xxx.rpm #查看该rpm文件中包含的文件\n48. rpm -qa| grep xxx #查看已经安装的rpm中名字包含xxx的\n49. rpm -e xxx ( –nodeps ) #(强制)卸载，使用时一定要确认该rpm不被其他重要的软件所依赖，否则会导致系统故障！！！\n50. rpm -e xxx #以普通用户身份执行，会因为权限不足/依赖关系而无法卸载，可以查看到依赖于xxx的程序\n51. ssh user@hostname cmd #在远程主机上执行cmd命令，但不登录，直接返回结果，可能会遇到找不到命令的问题：  \n\t#[mpp2@metadb1 ~]$ ssh node10 jps  \n\t#bash: jps: command not found  \n这是因为这种执行命令的方式和登陆到该主机上执行的方式所读取的配置文件不一样，所以环境变量有可能不同，这种方式会读取~/.bashrc 文件，所以需要在这里配置所需环境变量。详见：http://www.kuqin.com/shuoit/20141113/343188.html\n52. shell 通配符：  \n\tll seald.[EFIW][A-Z]* 中括号里面匹配任何一个字符，表示0个或多个，？表示一个\n \trm -f xxx.20151026-1[!5]\\ 删除除了xxx-15*以外的其他文件\n53. 在指定文件类型中查找关键字xxx：\n\tfind . -name “.h” |xargs grep xxx\n\t注意.h要加双引号，否则不好使","source":"_posts/Linux-Shell命令总结.md","raw":"---\ntitle: Linux Shell命令总结\ndate: 2017-04-03 10:36:53\ntags: [shell, Linux]\n---\n\n1. 使用find命令找到大于指定大小的文件：  \n\tfind /-type f -size +10G\n2. 在Linux下如何让文件夹下的文件让文件按大小排序？  \n\t方法一：# ls -lhSl 长格式显示，h human readable模式，大小单位为M,G等易读格式，S size按大小排序；  \n    方法二：# du -h | sort -n\n\t当然您也可以结合管道查看文件夹内最大的几个文件或最小的几个文件, 再加上管道符号和head或者tail命令即可du -h | sort -n|head du -h * | sort -n|tail\n3. 命令最后加上 & 符号表示在后台执行，shell不会阻塞；\n4. rz 在xshell中接收文件\n5. sz filename 在xshell中发送文件到windows主机\n6. sudo su #切换到root shell\n7. more /etc/issue #查看操作系统版本\n8. 查找文件：\n\tfind /path -name filename #系统内查找该文件(文件名必须是全的，不能部分匹配)  \n\tgrep xxx path/* -nr #搜索path路径下包含xxx内容的文件(只查找文件)，n表示显示行号，r表示在path子目录中递归执行  \n\tlocate filename  \n9. [sudo] kill -9 进程号 #杀死进程，前面的sudo可选\n10. ps –ef | grep 进程名 #查看包含进程名的进程，如 ps -ef | grep hive\n11. lsof –i:端口号 #查看端口号占用情况\n12. netstat –nltp | grep 进程号 #RedHat查看进程号所占用的端口号  \n\tnetstat -an | grep 端口号 #查看端口占用情况  \n13. sudo fuser 端口号/tcp #查看tcp端口占用的进程号\n14. 组合：ps -ef | grep $(fuser 端口号/tcp)\n15. netstat -anp | grep pid #ubuntu:查看进程占用端口号\n16. sudo cat /etc/group #查看用户组\n17. sudo cat /etc/passwd #查看所有用户\n18. sudo useradd xxx\n19. sudo userdel name\n20. sudo usermod -a -G groupname username\n21. sudo rpm -ivh xxx.rpm\n22. sudo rpm -e xxx\n23. sudo yum install xxx\n24. sudo yum remove xxx\n25. ln -s source/folder targetLinkName(不存在的一个名字) #注意删除软连接内容相当于删除了真实的文件\n26. du -sh /folder1/ #查看folder1目录占用的总空间\n27. du -sh /folder1/* #查看folder1目录里面各个子文件（夹）空间占用情况\n28. df -lh #查看各个文件系统空间占用情况\n29. tailf xxx.log #显示log文件最后十行内容，文件变时会自动更新，与 tail -f 命令的区别是log文件长度不变时不会自动读磁盘，故更省资源\n30. sudo chkconfig mysqld on/off #设置/关闭 开机自启动\n31. Ctrl r 进入reverse-i(incremental)-search 反向增量搜索模式，输入字母即可搜索出历史命令，按左右方向键开始编辑命令；\n32. vi - #以stdin的内容为内容编辑一个新文件\n33. grep xxx path/* -nr | vi - #即将查找到的行作为内容显示在一个新文件中，用vi打开\n34. pdsh -R ssh -g groupname “ls -l” 在配置好的无密码登陆集群执行ls命令，注意可以在双引号里执行多条命令，命令之间用分号隔开；注意执行多条命令时必须用引号括起来；\n35. pdsh -g mpp-jia tar xzf /tmp/mpp-patch.tgz -C `pwd` 以执行本命令的机器上的当前目录为目标目录（pwd命令的结果），在几个节点上解压tgz文件\n36. tar -cvf xxx.tar.gz /dir #打包dir目录\n37. tar -xvf xxx.tar.gz #解压缩\n38. bunzip2 linux-2-4-2.tar.bz2 #解压生成 .tar文件\n39. tar xvf linux-2-4-2.tar #解压 .tar文件\n40. tar jxvf linux-2-4-2.tar.bz2 #一次性解压，等价于以上两条命令\n41. cp -r /source /dest/ #将source目录复制到dest中，会在dest中自动新建一个source目录\n42. cp -r /source/ /dest/ #将source中的子目录复制到dest中\n43. env | grep hbase #查看hbase相关的环境变量配置信息\n44. . xx.sh 和 ./xx.sh 优先使用前者,因为后者会新开一个子shell，在子shell里执行，而前者是在当前shell里执行\n45. xx.sh == source xx.sh\n46. ./xx.sh == sh xx.sh == bash xx.sh\n47. rpm -qlp xxx.rpm #查看该rpm文件中包含的文件\n48. rpm -qa| grep xxx #查看已经安装的rpm中名字包含xxx的\n49. rpm -e xxx ( –nodeps ) #(强制)卸载，使用时一定要确认该rpm不被其他重要的软件所依赖，否则会导致系统故障！！！\n50. rpm -e xxx #以普通用户身份执行，会因为权限不足/依赖关系而无法卸载，可以查看到依赖于xxx的程序\n51. ssh user@hostname cmd #在远程主机上执行cmd命令，但不登录，直接返回结果，可能会遇到找不到命令的问题：  \n\t#[mpp2@metadb1 ~]$ ssh node10 jps  \n\t#bash: jps: command not found  \n这是因为这种执行命令的方式和登陆到该主机上执行的方式所读取的配置文件不一样，所以环境变量有可能不同，这种方式会读取~/.bashrc 文件，所以需要在这里配置所需环境变量。详见：http://www.kuqin.com/shuoit/20141113/343188.html\n52. shell 通配符：  \n\tll seald.[EFIW][A-Z]* 中括号里面匹配任何一个字符，表示0个或多个，？表示一个\n \trm -f xxx.20151026-1[!5]\\ 删除除了xxx-15*以外的其他文件\n53. 在指定文件类型中查找关键字xxx：\n\tfind . -name “.h” |xargs grep xxx\n\t注意.h要加双引号，否则不好使","slug":"Linux-Shell命令总结","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahb0003pvs6mt37s58c","content":"<ol>\n<li>使用find命令找到大于指定大小的文件：<br> find /-type f -size +10G</li>\n<li>在Linux下如何让文件夹下的文件让文件按大小排序？<br> 方法一：# ls -lhSl 长格式显示，h human readable模式，大小单位为M,G等易读格式，S size按大小排序；<br> 方法二：# du -h | sort -n<br> 当然您也可以结合管道查看文件夹内最大的几个文件或最小的几个文件, 再加上管道符号和head或者tail命令即可du -h | sort -n|head du -h * | sort -n|tail</li>\n<li>命令最后加上 &amp; 符号表示在后台执行，shell不会阻塞；</li>\n<li>rz 在xshell中接收文件</li>\n<li>sz filename 在xshell中发送文件到windows主机</li>\n<li>sudo su #切换到root shell</li>\n<li>more /etc/issue #查看操作系统版本</li>\n<li>查找文件：<br> find /path -name filename #系统内查找该文件(文件名必须是全的，不能部分匹配)<br> grep xxx path/* -nr #搜索path路径下包含xxx内容的文件(只查找文件)，n表示显示行号，r表示在path子目录中递归执行<br> locate filename  </li>\n<li>[sudo] kill -9 进程号 #杀死进程，前面的sudo可选</li>\n<li>ps –ef | grep 进程名 #查看包含进程名的进程，如 ps -ef | grep hive</li>\n<li>lsof –i:端口号 #查看端口号占用情况</li>\n<li>netstat –nltp | grep 进程号 #RedHat查看进程号所占用的端口号<br>netstat -an | grep 端口号 #查看端口占用情况  </li>\n<li>sudo fuser 端口号/tcp #查看tcp端口占用的进程号</li>\n<li>组合：ps -ef | grep $(fuser 端口号/tcp)</li>\n<li>netstat -anp | grep pid #ubuntu:查看进程占用端口号</li>\n<li>sudo cat /etc/group #查看用户组</li>\n<li>sudo cat /etc/passwd #查看所有用户</li>\n<li>sudo useradd xxx</li>\n<li>sudo userdel name</li>\n<li>sudo usermod -a -G groupname username</li>\n<li>sudo rpm -ivh xxx.rpm</li>\n<li>sudo rpm -e xxx</li>\n<li>sudo yum install xxx</li>\n<li>sudo yum remove xxx</li>\n<li>ln -s source/folder targetLinkName(不存在的一个名字) #注意删除软连接内容相当于删除了真实的文件</li>\n<li>du -sh /folder1/ #查看folder1目录占用的总空间</li>\n<li>du -sh /folder1/* #查看folder1目录里面各个子文件（夹）空间占用情况</li>\n<li>df -lh #查看各个文件系统空间占用情况</li>\n<li>tailf xxx.log #显示log文件最后十行内容，文件变时会自动更新，与 tail -f 命令的区别是log文件长度不变时不会自动读磁盘，故更省资源</li>\n<li>sudo chkconfig mysqld on/off #设置/关闭 开机自启动</li>\n<li>Ctrl r 进入reverse-i(incremental)-search 反向增量搜索模式，输入字母即可搜索出历史命令，按左右方向键开始编辑命令；</li>\n<li>vi - #以stdin的内容为内容编辑一个新文件</li>\n<li>grep xxx path/* -nr | vi - #即将查找到的行作为内容显示在一个新文件中，用vi打开</li>\n<li>pdsh -R ssh -g groupname “ls -l” 在配置好的无密码登陆集群执行ls命令，注意可以在双引号里执行多条命令，命令之间用分号隔开；注意执行多条命令时必须用引号括起来；</li>\n<li>pdsh -g mpp-jia tar xzf /tmp/mpp-patch.tgz -C <code>pwd</code> 以执行本命令的机器上的当前目录为目标目录（pwd命令的结果），在几个节点上解压tgz文件</li>\n<li>tar -cvf xxx.tar.gz /dir #打包dir目录</li>\n<li>tar -xvf xxx.tar.gz #解压缩</li>\n<li>bunzip2 linux-2-4-2.tar.bz2 #解压生成 .tar文件</li>\n<li>tar xvf linux-2-4-2.tar #解压 .tar文件</li>\n<li>tar jxvf linux-2-4-2.tar.bz2 #一次性解压，等价于以上两条命令</li>\n<li>cp -r /source /dest/ #将source目录复制到dest中，会在dest中自动新建一个source目录</li>\n<li>cp -r /source/ /dest/ #将source中的子目录复制到dest中</li>\n<li>env | grep hbase #查看hbase相关的环境变量配置信息</li>\n<li>. xx.sh 和 ./xx.sh 优先使用前者,因为后者会新开一个子shell，在子shell里执行，而前者是在当前shell里执行</li>\n<li>xx.sh == source xx.sh</li>\n<li>./xx.sh == sh xx.sh == bash xx.sh</li>\n<li>rpm -qlp xxx.rpm #查看该rpm文件中包含的文件</li>\n<li>rpm -qa| grep xxx #查看已经安装的rpm中名字包含xxx的</li>\n<li>rpm -e xxx ( –nodeps ) #(强制)卸载，使用时一定要确认该rpm不被其他重要的软件所依赖，否则会导致系统故障！！！</li>\n<li>rpm -e xxx #以普通用户身份执行，会因为权限不足/依赖关系而无法卸载，可以查看到依赖于xxx的程序</li>\n<li>ssh user@hostname cmd #在远程主机上执行cmd命令，但不登录，直接返回结果，可能会遇到找不到命令的问题：<br>#[mpp2@metadb1 ~]$ ssh node10 jps<br>#bash: jps: command not found<br>这是因为这种执行命令的方式和登陆到该主机上执行的方式所读取的配置文件不一样，所以环境变量有可能不同，这种方式会读取~/.bashrc 文件，所以需要在这里配置所需环境变量。详见：<a href=\"http://www.kuqin.com/shuoit/20141113/343188.html\" target=\"_blank\" rel=\"external\">http://www.kuqin.com/shuoit/20141113/343188.html</a></li>\n<li>shell 通配符：<br>ll seald.[EFIW][A-Z]<em> 中括号里面匹配任何一个字符，表示0个或多个，？表示一个<br> rm -f xxx.20151026-1[!5]\\ 删除除了xxx-15</em>以外的其他文件</li>\n<li>在指定文件类型中查找关键字xxx：<br>find . -name “.h” |xargs grep xxx<br>注意.h要加双引号，否则不好使</li>\n</ol>\n","excerpt":"","more":"<ol>\n<li>使用find命令找到大于指定大小的文件：<br> find /-type f -size +10G</li>\n<li>在Linux下如何让文件夹下的文件让文件按大小排序？<br> 方法一：# ls -lhSl 长格式显示，h human readable模式，大小单位为M,G等易读格式，S size按大小排序；<br> 方法二：# du -h | sort -n<br> 当然您也可以结合管道查看文件夹内最大的几个文件或最小的几个文件, 再加上管道符号和head或者tail命令即可du -h | sort -n|head du -h * | sort -n|tail</li>\n<li>命令最后加上 &amp; 符号表示在后台执行，shell不会阻塞；</li>\n<li>rz 在xshell中接收文件</li>\n<li>sz filename 在xshell中发送文件到windows主机</li>\n<li>sudo su #切换到root shell</li>\n<li>more /etc/issue #查看操作系统版本</li>\n<li>查找文件：<br> find /path -name filename #系统内查找该文件(文件名必须是全的，不能部分匹配)<br> grep xxx path/* -nr #搜索path路径下包含xxx内容的文件(只查找文件)，n表示显示行号，r表示在path子目录中递归执行<br> locate filename  </li>\n<li>[sudo] kill -9 进程号 #杀死进程，前面的sudo可选</li>\n<li>ps –ef | grep 进程名 #查看包含进程名的进程，如 ps -ef | grep hive</li>\n<li>lsof –i:端口号 #查看端口号占用情况</li>\n<li>netstat –nltp | grep 进程号 #RedHat查看进程号所占用的端口号<br>netstat -an | grep 端口号 #查看端口占用情况  </li>\n<li>sudo fuser 端口号/tcp #查看tcp端口占用的进程号</li>\n<li>组合：ps -ef | grep $(fuser 端口号/tcp)</li>\n<li>netstat -anp | grep pid #ubuntu:查看进程占用端口号</li>\n<li>sudo cat /etc/group #查看用户组</li>\n<li>sudo cat /etc/passwd #查看所有用户</li>\n<li>sudo useradd xxx</li>\n<li>sudo userdel name</li>\n<li>sudo usermod -a -G groupname username</li>\n<li>sudo rpm -ivh xxx.rpm</li>\n<li>sudo rpm -e xxx</li>\n<li>sudo yum install xxx</li>\n<li>sudo yum remove xxx</li>\n<li>ln -s source/folder targetLinkName(不存在的一个名字) #注意删除软连接内容相当于删除了真实的文件</li>\n<li>du -sh /folder1/ #查看folder1目录占用的总空间</li>\n<li>du -sh /folder1/* #查看folder1目录里面各个子文件（夹）空间占用情况</li>\n<li>df -lh #查看各个文件系统空间占用情况</li>\n<li>tailf xxx.log #显示log文件最后十行内容，文件变时会自动更新，与 tail -f 命令的区别是log文件长度不变时不会自动读磁盘，故更省资源</li>\n<li>sudo chkconfig mysqld on/off #设置/关闭 开机自启动</li>\n<li>Ctrl r 进入reverse-i(incremental)-search 反向增量搜索模式，输入字母即可搜索出历史命令，按左右方向键开始编辑命令；</li>\n<li>vi - #以stdin的内容为内容编辑一个新文件</li>\n<li>grep xxx path/* -nr | vi - #即将查找到的行作为内容显示在一个新文件中，用vi打开</li>\n<li>pdsh -R ssh -g groupname “ls -l” 在配置好的无密码登陆集群执行ls命令，注意可以在双引号里执行多条命令，命令之间用分号隔开；注意执行多条命令时必须用引号括起来；</li>\n<li>pdsh -g mpp-jia tar xzf /tmp/mpp-patch.tgz -C <code>pwd</code> 以执行本命令的机器上的当前目录为目标目录（pwd命令的结果），在几个节点上解压tgz文件</li>\n<li>tar -cvf xxx.tar.gz /dir #打包dir目录</li>\n<li>tar -xvf xxx.tar.gz #解压缩</li>\n<li>bunzip2 linux-2-4-2.tar.bz2 #解压生成 .tar文件</li>\n<li>tar xvf linux-2-4-2.tar #解压 .tar文件</li>\n<li>tar jxvf linux-2-4-2.tar.bz2 #一次性解压，等价于以上两条命令</li>\n<li>cp -r /source /dest/ #将source目录复制到dest中，会在dest中自动新建一个source目录</li>\n<li>cp -r /source/ /dest/ #将source中的子目录复制到dest中</li>\n<li>env | grep hbase #查看hbase相关的环境变量配置信息</li>\n<li>. xx.sh 和 ./xx.sh 优先使用前者,因为后者会新开一个子shell，在子shell里执行，而前者是在当前shell里执行</li>\n<li>xx.sh == source xx.sh</li>\n<li>./xx.sh == sh xx.sh == bash xx.sh</li>\n<li>rpm -qlp xxx.rpm #查看该rpm文件中包含的文件</li>\n<li>rpm -qa| grep xxx #查看已经安装的rpm中名字包含xxx的</li>\n<li>rpm -e xxx ( –nodeps ) #(强制)卸载，使用时一定要确认该rpm不被其他重要的软件所依赖，否则会导致系统故障！！！</li>\n<li>rpm -e xxx #以普通用户身份执行，会因为权限不足/依赖关系而无法卸载，可以查看到依赖于xxx的程序</li>\n<li>ssh user@hostname cmd #在远程主机上执行cmd命令，但不登录，直接返回结果，可能会遇到找不到命令的问题：<br>#[mpp2@metadb1 ~]$ ssh node10 jps<br>#bash: jps: command not found<br>这是因为这种执行命令的方式和登陆到该主机上执行的方式所读取的配置文件不一样，所以环境变量有可能不同，这种方式会读取~/.bashrc 文件，所以需要在这里配置所需环境变量。详见：<a href=\"http://www.kuqin.com/shuoit/20141113/343188.html\">http://www.kuqin.com/shuoit/20141113/343188.html</a></li>\n<li>shell 通配符：<br>ll seald.[EFIW][A-Z]<em> 中括号里面匹配任何一个字符，表示0个或多个，？表示一个<br> rm -f xxx.20151026-1[!5]\\ 删除除了xxx-15</em>以外的其他文件</li>\n<li>在指定文件类型中查找关键字xxx：<br>find . -name “.h” |xargs grep xxx<br>注意.h要加双引号，否则不好使</li>\n</ol>\n"},{"title":"C++语言相关","date":"2017-04-03T08:21:09.000Z","_content":"\n1、volatile：修饰符表示每次读取变量的值都从内存地址读取，不读寄存器。对于多线程访问的值来说，如果不加volatile，编译器可能进行优化，直接从寄存器读取该值，这样的话某个线程修改了该变量，寄存器中的值可能是脏数据，其他线程读取时就会读到旧值。  \n2、mutable：修饰的变量在const函数中也可以被修改。  \n3、C++ 枚举类型与int相互转换问题，编译器支持自动将枚举转换为int，但不支持int自动转枚举，需要强制转换。参考。  \n4、namespace使用时直接以 :: 开头，如 ::val = x;   表示此处的变量val是全局作用域中的val，如果定义了一个全局变量val，函数内部也定义了一个局部变量val，那么要想使用这个全局的val，就需要加上全局作用域标识符。  \n5、宏USED_PARA的[作用](http://www.cnblogs.com/verygis/archive/2012/05/03/2480130.html)：  \n```\n#ifndef   UNUSED_PARAM\n#define   UNUSED_PARAM(v)   (void)(v)\n#endif\n```\n假如一个有返回值的函数，如调用时是没有使用它的返回值，编译器会给出一个警告，用void强制转换一下，则明确告诉编译器不使用返回值，这样可以消除编译警告。因为如果采用严格的编译模式，未使用的变量编译时会报错。  \n6、REACH_TIME_INTERVAL宏的作用是判断是否达到指定的时间间隔：  \n```\n#define REACH_TIME_INTERVAL(i) \\\n  ({ \\\n    bool ret = false; \\\n    static volatile int64_t last_time = 0; \\\n    int64_t cur_time = ::common::current_time(); \\\n    int64_t old_time = last_time; \\\n    if ((i + last_time) < cur_time \\\n        && old_time == ATOMIC_CAS(&last_time, old_time, cur_time)) \\\n    { \\\n      ret = true; \\\n    } \\\n    ret; \\\n  })\n```\n该宏返回bool值，参数i为微秒数，比如1000*1000表示1秒，last_time为static且volatile的，这样多个线程将访问到相同的值，if判断中第一个条件表示cur_time是否已经超出了last_time指定的间隔i，如果不是则跳出if并返回false，否则判断第二个条件，第二个条件为了控制并发访问，原子地更新last_time的值，如果自从old_time被赋值之后没有其他线程修改last_time的值，那么就返回true，说明超过了间隔i。比如last_time=10000，i=200，cur_time=10222，那么就说明超过了间隔。该宏的应用场景是避免一些频繁的操作，如多线程打印日志，可以限制至少经过10秒才打印一次，避免日志过多。  \n7、自旋锁特点：busy-waiting，普通读写锁和mutex则是sleep-waiting。例如在一个双核的机器上有两个线程(A和B)，分别运行在核心和 核心1上。假设线程A想要通过pthread_mutex_lock对临界区加锁，而此时这个锁正被线程B所持有，那么A就会阻塞 (blocking)，Core0会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。而Spin lock则不然，如果使用的是自旋锁，那么线程A就会一直在Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。自旋锁的效率比普通锁要高，但是代价是更高的CPU占用。\ntry_lock和lock的区别就是try_lock获取不到锁时不会等待，避免死等。  \n8、explicit关键字的作用：只能用于修饰类的构造函数（通常用于修饰带参数的构造函数），这样的类不会发生隐式类型转换。  \n9、LIKELY、UNLIKELY 可以给编译器提示，减少分支预测错误的出现。  \n10、在.cpp文件中定义成员函数，函数中使用类的成员变量时编译报错：xxx was not declared in this scope.  \n原因：低级错误，该成员函数名字前面没有加类名作用域。  \n11、C++ 枚举类型与int相互转换：编译器支持自动将枚举转换为int，但不支持int自动转枚举，需要强制转换。  \n但是在g++编译器中，即使用强制转换运行时也会报拒绝访问。  \n```\nenum Day {\n  Monday,\n  Tuesday,\n  Wednesday\n};\nint main()\n{\n  Day d = Tuesday;\n  cout << d << endl;  //输出1\n  d = Day(0);         //编译通过，运行时报拒绝访问\n  cout << d << endl;\n  return 0;\n}\n```\n总之，在使用枚举类型时，记得按照枚举变量名方式赋值才算正确使用方式。\n参考自[博客](http://blog.csdn.net/lihao21/article/details/6825722)。\n12、LIKELY/UNLIKELY宏：在代码中经常可以看到如下代码：  \n```\n#define likely(x)       __builtin_expect(!!(x), 1)  //用!!的目的是对于大于1的x取非一次得到0，再取非则得到1\n#define unlikely(x)     __builtin_expect(!!(x), 0)\nif(LIKELY(x > 0)) {\n  y = 1;\n} else {\n  y = -1;\n}\n```\n对于这两个宏的意义，我们首先从CPU的指令流水线谈起，CPU为了提高指令执行的效率，采用流水线技术来预取下一条指令，如下图：  \n+————————————————————  \n|取指令1|执行指令|输出结果|  \n+————————————————————  \n|空空空空|取指令2|执行指令|输出结果  \n+————————————————————  \n|空空空空空空空空|取指令3 …  \n+————————————————————  \n通常如果指令1、2、3是程序的真实执行顺序的话这样做没有问题，但是如果指令1是一个if判断，判断条件失败时就会发生分支跳转，指令2不再是下一条要执行的指令，这时CPU就需要重新从内存中读取目标指令替换指令2，这样执行效率就比较低了。分支预测失败就会降低指令预取的效果，因此GCC编译器为程序员提供了帮助处理分支预测的函数，可以提高分支预测的准确性，优化程序性能。  \n比如上面的示例代码，由于LIKELY表明 x>0 的概率比较高，这样gcc编译器编译出来的指令会预取 y=1 这条指令，如果 x>0 的概率很小，则应该将LIKELY替换为UNLIKELY，这样预取的指令会变为 y=-1。\n也就是说，gcc编译器编译过程中总是会预取出更可能发生的指令，而LIKELY/UNLIKELY正是程序员给编译器的暗示，让程序性能优化得更高。  \n参考[文章](https://my.oschina.net/moooofly/blog/175019)  \n\n\n","source":"_posts/C-语言相关.md","raw":"---\ntitle: C++语言相关\ndate: 2017-04-03 16:21:09\ntags:\n---\n\n1、volatile：修饰符表示每次读取变量的值都从内存地址读取，不读寄存器。对于多线程访问的值来说，如果不加volatile，编译器可能进行优化，直接从寄存器读取该值，这样的话某个线程修改了该变量，寄存器中的值可能是脏数据，其他线程读取时就会读到旧值。  \n2、mutable：修饰的变量在const函数中也可以被修改。  \n3、C++ 枚举类型与int相互转换问题，编译器支持自动将枚举转换为int，但不支持int自动转枚举，需要强制转换。参考。  \n4、namespace使用时直接以 :: 开头，如 ::val = x;   表示此处的变量val是全局作用域中的val，如果定义了一个全局变量val，函数内部也定义了一个局部变量val，那么要想使用这个全局的val，就需要加上全局作用域标识符。  \n5、宏USED_PARA的[作用](http://www.cnblogs.com/verygis/archive/2012/05/03/2480130.html)：  \n```\n#ifndef   UNUSED_PARAM\n#define   UNUSED_PARAM(v)   (void)(v)\n#endif\n```\n假如一个有返回值的函数，如调用时是没有使用它的返回值，编译器会给出一个警告，用void强制转换一下，则明确告诉编译器不使用返回值，这样可以消除编译警告。因为如果采用严格的编译模式，未使用的变量编译时会报错。  \n6、REACH_TIME_INTERVAL宏的作用是判断是否达到指定的时间间隔：  \n```\n#define REACH_TIME_INTERVAL(i) \\\n  ({ \\\n    bool ret = false; \\\n    static volatile int64_t last_time = 0; \\\n    int64_t cur_time = ::common::current_time(); \\\n    int64_t old_time = last_time; \\\n    if ((i + last_time) < cur_time \\\n        && old_time == ATOMIC_CAS(&last_time, old_time, cur_time)) \\\n    { \\\n      ret = true; \\\n    } \\\n    ret; \\\n  })\n```\n该宏返回bool值，参数i为微秒数，比如1000*1000表示1秒，last_time为static且volatile的，这样多个线程将访问到相同的值，if判断中第一个条件表示cur_time是否已经超出了last_time指定的间隔i，如果不是则跳出if并返回false，否则判断第二个条件，第二个条件为了控制并发访问，原子地更新last_time的值，如果自从old_time被赋值之后没有其他线程修改last_time的值，那么就返回true，说明超过了间隔i。比如last_time=10000，i=200，cur_time=10222，那么就说明超过了间隔。该宏的应用场景是避免一些频繁的操作，如多线程打印日志，可以限制至少经过10秒才打印一次，避免日志过多。  \n7、自旋锁特点：busy-waiting，普通读写锁和mutex则是sleep-waiting。例如在一个双核的机器上有两个线程(A和B)，分别运行在核心和 核心1上。假设线程A想要通过pthread_mutex_lock对临界区加锁，而此时这个锁正被线程B所持有，那么A就会阻塞 (blocking)，Core0会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。而Spin lock则不然，如果使用的是自旋锁，那么线程A就会一直在Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。自旋锁的效率比普通锁要高，但是代价是更高的CPU占用。\ntry_lock和lock的区别就是try_lock获取不到锁时不会等待，避免死等。  \n8、explicit关键字的作用：只能用于修饰类的构造函数（通常用于修饰带参数的构造函数），这样的类不会发生隐式类型转换。  \n9、LIKELY、UNLIKELY 可以给编译器提示，减少分支预测错误的出现。  \n10、在.cpp文件中定义成员函数，函数中使用类的成员变量时编译报错：xxx was not declared in this scope.  \n原因：低级错误，该成员函数名字前面没有加类名作用域。  \n11、C++ 枚举类型与int相互转换：编译器支持自动将枚举转换为int，但不支持int自动转枚举，需要强制转换。  \n但是在g++编译器中，即使用强制转换运行时也会报拒绝访问。  \n```\nenum Day {\n  Monday,\n  Tuesday,\n  Wednesday\n};\nint main()\n{\n  Day d = Tuesday;\n  cout << d << endl;  //输出1\n  d = Day(0);         //编译通过，运行时报拒绝访问\n  cout << d << endl;\n  return 0;\n}\n```\n总之，在使用枚举类型时，记得按照枚举变量名方式赋值才算正确使用方式。\n参考自[博客](http://blog.csdn.net/lihao21/article/details/6825722)。\n12、LIKELY/UNLIKELY宏：在代码中经常可以看到如下代码：  \n```\n#define likely(x)       __builtin_expect(!!(x), 1)  //用!!的目的是对于大于1的x取非一次得到0，再取非则得到1\n#define unlikely(x)     __builtin_expect(!!(x), 0)\nif(LIKELY(x > 0)) {\n  y = 1;\n} else {\n  y = -1;\n}\n```\n对于这两个宏的意义，我们首先从CPU的指令流水线谈起，CPU为了提高指令执行的效率，采用流水线技术来预取下一条指令，如下图：  \n+————————————————————  \n|取指令1|执行指令|输出结果|  \n+————————————————————  \n|空空空空|取指令2|执行指令|输出结果  \n+————————————————————  \n|空空空空空空空空|取指令3 …  \n+————————————————————  \n通常如果指令1、2、3是程序的真实执行顺序的话这样做没有问题，但是如果指令1是一个if判断，判断条件失败时就会发生分支跳转，指令2不再是下一条要执行的指令，这时CPU就需要重新从内存中读取目标指令替换指令2，这样执行效率就比较低了。分支预测失败就会降低指令预取的效果，因此GCC编译器为程序员提供了帮助处理分支预测的函数，可以提高分支预测的准确性，优化程序性能。  \n比如上面的示例代码，由于LIKELY表明 x>0 的概率比较高，这样gcc编译器编译出来的指令会预取 y=1 这条指令，如果 x>0 的概率很小，则应该将LIKELY替换为UNLIKELY，这样预取的指令会变为 y=-1。\n也就是说，gcc编译器编译过程中总是会预取出更可能发生的指令，而LIKELY/UNLIKELY正是程序员给编译器的暗示，让程序性能优化得更高。  \n参考[文章](https://my.oschina.net/moooofly/blog/175019)  \n\n\n","slug":"C-语言相关","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahd0004pvs6y2ks5v85","content":"<p>1、volatile：修饰符表示每次读取变量的值都从内存地址读取，不读寄存器。对于多线程访问的值来说，如果不加volatile，编译器可能进行优化，直接从寄存器读取该值，这样的话某个线程修改了该变量，寄存器中的值可能是脏数据，其他线程读取时就会读到旧值。<br>2、mutable：修饰的变量在const函数中也可以被修改。<br>3、C++ 枚举类型与int相互转换问题，编译器支持自动将枚举转换为int，但不支持int自动转枚举，需要强制转换。参考。<br>4、namespace使用时直接以 :: 开头，如 ::val = x;   表示此处的变量val是全局作用域中的val，如果定义了一个全局变量val，函数内部也定义了一个局部变量val，那么要想使用这个全局的val，就需要加上全局作用域标识符。<br>5、宏USED_PARA的<a href=\"http://www.cnblogs.com/verygis/archive/2012/05/03/2480130.html\" target=\"_blank\" rel=\"external\">作用</a>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef   UNUSED_PARAM</div><div class=\"line\">#define   UNUSED_PARAM(v)   (void)(v)</div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<p>假如一个有返回值的函数，如调用时是没有使用它的返回值，编译器会给出一个警告，用void强制转换一下，则明确告诉编译器不使用返回值，这样可以消除编译警告。因为如果采用严格的编译模式，未使用的变量编译时会报错。<br>6、REACH_TIME_INTERVAL宏的作用是判断是否达到指定的时间间隔：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define REACH_TIME_INTERVAL(i) \\</div><div class=\"line\">  (&#123; \\</div><div class=\"line\">    bool ret = false; \\</div><div class=\"line\">    static volatile int64_t last_time = 0; \\</div><div class=\"line\">    int64_t cur_time = ::common::current_time(); \\</div><div class=\"line\">    int64_t old_time = last_time; \\</div><div class=\"line\">    if ((i + last_time) &lt; cur_time \\</div><div class=\"line\">        &amp;&amp; old_time == ATOMIC_CAS(&amp;last_time, old_time, cur_time)) \\</div><div class=\"line\">    &#123; \\</div><div class=\"line\">      ret = true; \\</div><div class=\"line\">    &#125; \\</div><div class=\"line\">    ret; \\</div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<p>该宏返回bool值，参数i为微秒数，比如1000*1000表示1秒，last_time为static且volatile的，这样多个线程将访问到相同的值，if判断中第一个条件表示cur_time是否已经超出了last_time指定的间隔i，如果不是则跳出if并返回false，否则判断第二个条件，第二个条件为了控制并发访问，原子地更新last_time的值，如果自从old_time被赋值之后没有其他线程修改last_time的值，那么就返回true，说明超过了间隔i。比如last_time=10000，i=200，cur_time=10222，那么就说明超过了间隔。该宏的应用场景是避免一些频繁的操作，如多线程打印日志，可以限制至少经过10秒才打印一次，避免日志过多。<br>7、自旋锁特点：busy-waiting，普通读写锁和mutex则是sleep-waiting。例如在一个双核的机器上有两个线程(A和B)，分别运行在核心和 核心1上。假设线程A想要通过pthread_mutex_lock对临界区加锁，而此时这个锁正被线程B所持有，那么A就会阻塞 (blocking)，Core0会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。而Spin lock则不然，如果使用的是自旋锁，那么线程A就会一直在Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。自旋锁的效率比普通锁要高，但是代价是更高的CPU占用。<br>try_lock和lock的区别就是try_lock获取不到锁时不会等待，避免死等。<br>8、explicit关键字的作用：只能用于修饰类的构造函数（通常用于修饰带参数的构造函数），这样的类不会发生隐式类型转换。<br>9、LIKELY、UNLIKELY 可以给编译器提示，减少分支预测错误的出现。<br>10、在.cpp文件中定义成员函数，函数中使用类的成员变量时编译报错：xxx was not declared in this scope.<br>原因：低级错误，该成员函数名字前面没有加类名作用域。<br>11、C++ 枚举类型与int相互转换：编译器支持自动将枚举转换为int，但不支持int自动转枚举，需要强制转换。<br>但是在g++编译器中，即使用强制转换运行时也会报拒绝访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum Day &#123;</div><div class=\"line\">  Monday,</div><div class=\"line\">  Tuesday,</div><div class=\"line\">  Wednesday</div><div class=\"line\">&#125;;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">  Day d = Tuesday;</div><div class=\"line\">  cout &lt;&lt; d &lt;&lt; endl;  //输出1</div><div class=\"line\">  d = Day(0);         //编译通过，运行时报拒绝访问</div><div class=\"line\">  cout &lt;&lt; d &lt;&lt; endl;</div><div class=\"line\">  return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>总之，在使用枚举类型时，记得按照枚举变量名方式赋值才算正确使用方式。<br>参考自<a href=\"http://blog.csdn.net/lihao21/article/details/6825722\" target=\"_blank\" rel=\"external\">博客</a>。<br>12、LIKELY/UNLIKELY宏：在代码中经常可以看到如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define likely(x)       __builtin_expect(!!(x), 1)  //用!!的目的是对于大于1的x取非一次得到0，再取非则得到1</div><div class=\"line\">#define unlikely(x)     __builtin_expect(!!(x), 0)</div><div class=\"line\">if(LIKELY(x &gt; 0)) &#123;</div><div class=\"line\">  y = 1;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  y = -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>对于这两个宏的意义，我们首先从CPU的指令流水线谈起，CPU为了提高指令执行的效率，采用流水线技术来预取下一条指令，如下图：<br>+————————————————————<br>|取指令1|执行指令|输出结果|<br>+————————————————————<br>|空空空空|取指令2|执行指令|输出结果<br>+————————————————————<br>|空空空空空空空空|取指令3 …<br>+————————————————————<br>通常如果指令1、2、3是程序的真实执行顺序的话这样做没有问题，但是如果指令1是一个if判断，判断条件失败时就会发生分支跳转，指令2不再是下一条要执行的指令，这时CPU就需要重新从内存中读取目标指令替换指令2，这样执行效率就比较低了。分支预测失败就会降低指令预取的效果，因此GCC编译器为程序员提供了帮助处理分支预测的函数，可以提高分支预测的准确性，优化程序性能。<br>比如上面的示例代码，由于LIKELY表明 x&gt;0 的概率比较高，这样gcc编译器编译出来的指令会预取 y=1 这条指令，如果 x&gt;0 的概率很小，则应该将LIKELY替换为UNLIKELY，这样预取的指令会变为 y=-1。<br>也就是说，gcc编译器编译过程中总是会预取出更可能发生的指令，而LIKELY/UNLIKELY正是程序员给编译器的暗示，让程序性能优化得更高。<br>参考<a href=\"https://my.oschina.net/moooofly/blog/175019\" target=\"_blank\" rel=\"external\">文章</a>  </p>\n","excerpt":"","more":"<p>1、volatile：修饰符表示每次读取变量的值都从内存地址读取，不读寄存器。对于多线程访问的值来说，如果不加volatile，编译器可能进行优化，直接从寄存器读取该值，这样的话某个线程修改了该变量，寄存器中的值可能是脏数据，其他线程读取时就会读到旧值。<br>2、mutable：修饰的变量在const函数中也可以被修改。<br>3、C++ 枚举类型与int相互转换问题，编译器支持自动将枚举转换为int，但不支持int自动转枚举，需要强制转换。参考。<br>4、namespace使用时直接以 :: 开头，如 ::val = x;   表示此处的变量val是全局作用域中的val，如果定义了一个全局变量val，函数内部也定义了一个局部变量val，那么要想使用这个全局的val，就需要加上全局作用域标识符。<br>5、宏USED_PARA的<a href=\"http://www.cnblogs.com/verygis/archive/2012/05/03/2480130.html\">作用</a>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef   UNUSED_PARAM</div><div class=\"line\">#define   UNUSED_PARAM(v)   (void)(v)</div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<p>假如一个有返回值的函数，如调用时是没有使用它的返回值，编译器会给出一个警告，用void强制转换一下，则明确告诉编译器不使用返回值，这样可以消除编译警告。因为如果采用严格的编译模式，未使用的变量编译时会报错。<br>6、REACH_TIME_INTERVAL宏的作用是判断是否达到指定的时间间隔：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define REACH_TIME_INTERVAL(i) \\</div><div class=\"line\">  (&#123; \\</div><div class=\"line\">    bool ret = false; \\</div><div class=\"line\">    static volatile int64_t last_time = 0; \\</div><div class=\"line\">    int64_t cur_time = ::common::current_time(); \\</div><div class=\"line\">    int64_t old_time = last_time; \\</div><div class=\"line\">    if ((i + last_time) &lt; cur_time \\</div><div class=\"line\">        &amp;&amp; old_time == ATOMIC_CAS(&amp;last_time, old_time, cur_time)) \\</div><div class=\"line\">    &#123; \\</div><div class=\"line\">      ret = true; \\</div><div class=\"line\">    &#125; \\</div><div class=\"line\">    ret; \\</div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<p>该宏返回bool值，参数i为微秒数，比如1000*1000表示1秒，last_time为static且volatile的，这样多个线程将访问到相同的值，if判断中第一个条件表示cur_time是否已经超出了last_time指定的间隔i，如果不是则跳出if并返回false，否则判断第二个条件，第二个条件为了控制并发访问，原子地更新last_time的值，如果自从old_time被赋值之后没有其他线程修改last_time的值，那么就返回true，说明超过了间隔i。比如last_time=10000，i=200，cur_time=10222，那么就说明超过了间隔。该宏的应用场景是避免一些频繁的操作，如多线程打印日志，可以限制至少经过10秒才打印一次，避免日志过多。<br>7、自旋锁特点：busy-waiting，普通读写锁和mutex则是sleep-waiting。例如在一个双核的机器上有两个线程(A和B)，分别运行在核心和 核心1上。假设线程A想要通过pthread_mutex_lock对临界区加锁，而此时这个锁正被线程B所持有，那么A就会阻塞 (blocking)，Core0会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。而Spin lock则不然，如果使用的是自旋锁，那么线程A就会一直在Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。自旋锁的效率比普通锁要高，但是代价是更高的CPU占用。<br>try_lock和lock的区别就是try_lock获取不到锁时不会等待，避免死等。<br>8、explicit关键字的作用：只能用于修饰类的构造函数（通常用于修饰带参数的构造函数），这样的类不会发生隐式类型转换。<br>9、LIKELY、UNLIKELY 可以给编译器提示，减少分支预测错误的出现。<br>10、在.cpp文件中定义成员函数，函数中使用类的成员变量时编译报错：xxx was not declared in this scope.<br>原因：低级错误，该成员函数名字前面没有加类名作用域。<br>11、C++ 枚举类型与int相互转换：编译器支持自动将枚举转换为int，但不支持int自动转枚举，需要强制转换。<br>但是在g++编译器中，即使用强制转换运行时也会报拒绝访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum Day &#123;</div><div class=\"line\">  Monday,</div><div class=\"line\">  Tuesday,</div><div class=\"line\">  Wednesday</div><div class=\"line\">&#125;;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">  Day d = Tuesday;</div><div class=\"line\">  cout &lt;&lt; d &lt;&lt; endl;  //输出1</div><div class=\"line\">  d = Day(0);         //编译通过，运行时报拒绝访问</div><div class=\"line\">  cout &lt;&lt; d &lt;&lt; endl;</div><div class=\"line\">  return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>总之，在使用枚举类型时，记得按照枚举变量名方式赋值才算正确使用方式。<br>参考自<a href=\"http://blog.csdn.net/lihao21/article/details/6825722\">博客</a>。<br>12、LIKELY/UNLIKELY宏：在代码中经常可以看到如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define likely(x)       __builtin_expect(!!(x), 1)  //用!!的目的是对于大于1的x取非一次得到0，再取非则得到1</div><div class=\"line\">#define unlikely(x)     __builtin_expect(!!(x), 0)</div><div class=\"line\">if(LIKELY(x &gt; 0)) &#123;</div><div class=\"line\">  y = 1;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  y = -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>对于这两个宏的意义，我们首先从CPU的指令流水线谈起，CPU为了提高指令执行的效率，采用流水线技术来预取下一条指令，如下图：<br>+————————————————————<br>|取指令1|执行指令|输出结果|<br>+————————————————————<br>|空空空空|取指令2|执行指令|输出结果<br>+————————————————————<br>|空空空空空空空空|取指令3 …<br>+————————————————————<br>通常如果指令1、2、3是程序的真实执行顺序的话这样做没有问题，但是如果指令1是一个if判断，判断条件失败时就会发生分支跳转，指令2不再是下一条要执行的指令，这时CPU就需要重新从内存中读取目标指令替换指令2，这样执行效率就比较低了。分支预测失败就会降低指令预取的效果，因此GCC编译器为程序员提供了帮助处理分支预测的函数，可以提高分支预测的准确性，优化程序性能。<br>比如上面的示例代码，由于LIKELY表明 x&gt;0 的概率比较高，这样gcc编译器编译出来的指令会预取 y=1 这条指令，如果 x&gt;0 的概率很小，则应该将LIKELY替换为UNLIKELY，这样预取的指令会变为 y=-1。<br>也就是说，gcc编译器编译过程中总是会预取出更可能发生的指令，而LIKELY/UNLIKELY正是程序员给编译器的暗示，让程序性能优化得更高。<br>参考<a href=\"https://my.oschina.net/moooofly/blog/175019\">文章</a>  </p>\n"},{"title":"Vim技巧","date":"2017-04-03T02:24:36.000Z","_content":"\n## 1 命令快捷键总结\n1. Ctrl+z 回到shell，在shell中输入fg回车回到vim\n2. 要同时在多行相同位置插入复制的内容，首先 Ctrl + v 选择位置，然后输入 大写i 进入编辑模式，然后 shift+insert 粘贴，最后Esc退出visual block模式，插入成功\n3. /xxx 查找xxx，按n/N 跳转到下一个/上一个匹配位置\n4. :vsp xxx 垂直分割窗口打开xxx\n\t:sp xxx 水平分割窗口\n5. :bn 和 :bp 切换上一个/下一个文件编辑窗口（或者Ctrl+ww）\n6. \\# 匹配上一个当前单词\n   \\* 匹配下一个当前单词\n7. :1, 5 copy 20 将1至5行内容复制到20行位置\n8. :d5 剪切从当前行开始的5行，用p粘贴到指定行\n9. dw 剪切当前字符开始的一个词，使用 p 粘贴\n10. cw 删除当前字符开始的单词，并进入插入模式（相当于替换当前单词内容）\n11. 0 移动到本行最开头\n\t$ 移动到本行最尾部\n\tw 移动到下一个单词起始字符处\n\te 移动到下一个单词结尾字符处\n12. % 匹配括号进行移动，可以从 ‘{‘ 移动到对应的 ‘}’，或者反之（首先得保证当前光标在某个半括号上，适用于大中小括号）\n13. u undo\n14. Ctrl+r redo\n15. Ctrl+p/n 自动补全，p表示向上查找匹配词，n表示向下查找；\n16. :s/xxx/yyy/ 将当前行中的第一个「xxx」替换为「yyy」\n\t:s/xxx/yyy/g 将当前行中的所有「xxx」替换为「yyy」\n\t:s/xxx/yyy/gc 同上，但每次替换都会询问\n\t:%s/xxx/yyy/g 将整个文件中的所有「xxx」替换为「yyy」\n17. Ctrl+o 回到上一次编辑处\n\tCtrl+i 回到下一次编辑处\n18. :x 等价于 :wq 等价于 ZZ 保存并退出\n19. vim -d file1 file2 比较两个文件不同之处\n20. 光标位置移动：\n\ta. 保持当前光标位置仅滚动屏幕内容：Ctrl+e/y\n\tb. 移动光标到上/下一个历史位置：Ctrl+o/i\n21. visual、visual行/列模式：\n\ta. visual模式：normal模式下按v进入该模式，移动光标可以选中光标首尾的内容；\n\tb. visual line模式：即行模式，normal模式下按大写V（或shift+v）进入该模式，移动光标可以选中对应的行；\n\tc. visual block模式：即列模式，normal模式下按Ctrl+v进入该模式，移动光标可以选中对应列的内容；\n\n## 2 ctags/taglist配置使用\n**用途：**  \nctags是一个工具软件，可以为大型项目的源代码生成标签，便于阅读源码时进行跨文件跳转，就像在windows中使用source insight一样，非常方便。\n\n**配置：**  \n1. 生成标签文件\n在项目根目录下执行如下命令：  \n$ctags -R .  \n其中-R表示递归地为当前目录及子目录中所有的源码文件生成标签文件tags，该文件会保存在当前目录下。  \n\n2. 使用tag进行跳转\n1) 用vim打开一个源码文件，随便找到一个变量或者函数调用位置  \n2) 按Ctrl+]可以跳转到该变量/函数定义的位置(可能位于其他文件)，如果有多个文件都包含同名的定义，那么它会以列表形式显示，让你输入编号进行选择  \n3) 按Ctrl+t跳回之前的位置  \n注意：此时打开vim必须在tags文件所在目录，否则会提示找不到tags文件，对于大项目，你可能需要在任意目录下查看源码，这就需要在.vimrc文件中增加一行：  \nset tags=tags;/   \n该命令指示vim在当前目录找不到ctags文件时，自动去上层目录查找。  \n\n3. taglist插件安装\ntaglist是一个vim插件，可以显示源码文件的梗概，如变量、方法列表。安装方法是到www.vim.org中搜索该plugin，然后下载、解压，它会自动解压到 ~/.vim/plugin 中，如果该目录不存在请手动创建。  \n安装完成之后，利用vim打开一个源码文件，然后进入 :命令模式，输入：  \n```\n:Tlist  \n```\n\n即可打开taglist窗口，按F1可以看到操作帮助，为了方便，也可以自己设置打开/关闭taglist的快捷键，比如用F8作为快捷键，则需在.vimrc中添加：  \n```\nnnoremap <silent> <F8> :TlistToggle<CR>\n```\n这样就可以利用F8打开/关闭taglist了。  \nctags显示跳转列表需要在vimrc文件中添加一行：  \n```\nset cscopetag\n```\n\n## 3 .vimrc配置(含快捷键)\n参考[文章1](http://www.360doc.com/content/13/0111/13/168576_259534618.shtml)\n参考[文章2](http://www.cnblogs.com/moodlxs/archive/2012/03/24/2415526.html)\n参考[文章3](http://vim.sourceforge.net/scripts/script.php?script_id=2506)\n参考[文章4](https://zybuluo.com/uuprince/note/81709)\n\n","source":"_posts/Vim技巧.md","raw":"---\ntitle: Vim技巧\ndate: 2017-04-03 10:24:36\ntags:\n---\n\n## 1 命令快捷键总结\n1. Ctrl+z 回到shell，在shell中输入fg回车回到vim\n2. 要同时在多行相同位置插入复制的内容，首先 Ctrl + v 选择位置，然后输入 大写i 进入编辑模式，然后 shift+insert 粘贴，最后Esc退出visual block模式，插入成功\n3. /xxx 查找xxx，按n/N 跳转到下一个/上一个匹配位置\n4. :vsp xxx 垂直分割窗口打开xxx\n\t:sp xxx 水平分割窗口\n5. :bn 和 :bp 切换上一个/下一个文件编辑窗口（或者Ctrl+ww）\n6. \\# 匹配上一个当前单词\n   \\* 匹配下一个当前单词\n7. :1, 5 copy 20 将1至5行内容复制到20行位置\n8. :d5 剪切从当前行开始的5行，用p粘贴到指定行\n9. dw 剪切当前字符开始的一个词，使用 p 粘贴\n10. cw 删除当前字符开始的单词，并进入插入模式（相当于替换当前单词内容）\n11. 0 移动到本行最开头\n\t$ 移动到本行最尾部\n\tw 移动到下一个单词起始字符处\n\te 移动到下一个单词结尾字符处\n12. % 匹配括号进行移动，可以从 ‘{‘ 移动到对应的 ‘}’，或者反之（首先得保证当前光标在某个半括号上，适用于大中小括号）\n13. u undo\n14. Ctrl+r redo\n15. Ctrl+p/n 自动补全，p表示向上查找匹配词，n表示向下查找；\n16. :s/xxx/yyy/ 将当前行中的第一个「xxx」替换为「yyy」\n\t:s/xxx/yyy/g 将当前行中的所有「xxx」替换为「yyy」\n\t:s/xxx/yyy/gc 同上，但每次替换都会询问\n\t:%s/xxx/yyy/g 将整个文件中的所有「xxx」替换为「yyy」\n17. Ctrl+o 回到上一次编辑处\n\tCtrl+i 回到下一次编辑处\n18. :x 等价于 :wq 等价于 ZZ 保存并退出\n19. vim -d file1 file2 比较两个文件不同之处\n20. 光标位置移动：\n\ta. 保持当前光标位置仅滚动屏幕内容：Ctrl+e/y\n\tb. 移动光标到上/下一个历史位置：Ctrl+o/i\n21. visual、visual行/列模式：\n\ta. visual模式：normal模式下按v进入该模式，移动光标可以选中光标首尾的内容；\n\tb. visual line模式：即行模式，normal模式下按大写V（或shift+v）进入该模式，移动光标可以选中对应的行；\n\tc. visual block模式：即列模式，normal模式下按Ctrl+v进入该模式，移动光标可以选中对应列的内容；\n\n## 2 ctags/taglist配置使用\n**用途：**  \nctags是一个工具软件，可以为大型项目的源代码生成标签，便于阅读源码时进行跨文件跳转，就像在windows中使用source insight一样，非常方便。\n\n**配置：**  \n1. 生成标签文件\n在项目根目录下执行如下命令：  \n$ctags -R .  \n其中-R表示递归地为当前目录及子目录中所有的源码文件生成标签文件tags，该文件会保存在当前目录下。  \n\n2. 使用tag进行跳转\n1) 用vim打开一个源码文件，随便找到一个变量或者函数调用位置  \n2) 按Ctrl+]可以跳转到该变量/函数定义的位置(可能位于其他文件)，如果有多个文件都包含同名的定义，那么它会以列表形式显示，让你输入编号进行选择  \n3) 按Ctrl+t跳回之前的位置  \n注意：此时打开vim必须在tags文件所在目录，否则会提示找不到tags文件，对于大项目，你可能需要在任意目录下查看源码，这就需要在.vimrc文件中增加一行：  \nset tags=tags;/   \n该命令指示vim在当前目录找不到ctags文件时，自动去上层目录查找。  \n\n3. taglist插件安装\ntaglist是一个vim插件，可以显示源码文件的梗概，如变量、方法列表。安装方法是到www.vim.org中搜索该plugin，然后下载、解压，它会自动解压到 ~/.vim/plugin 中，如果该目录不存在请手动创建。  \n安装完成之后，利用vim打开一个源码文件，然后进入 :命令模式，输入：  \n```\n:Tlist  \n```\n\n即可打开taglist窗口，按F1可以看到操作帮助，为了方便，也可以自己设置打开/关闭taglist的快捷键，比如用F8作为快捷键，则需在.vimrc中添加：  \n```\nnnoremap <silent> <F8> :TlistToggle<CR>\n```\n这样就可以利用F8打开/关闭taglist了。  \nctags显示跳转列表需要在vimrc文件中添加一行：  \n```\nset cscopetag\n```\n\n## 3 .vimrc配置(含快捷键)\n参考[文章1](http://www.360doc.com/content/13/0111/13/168576_259534618.shtml)\n参考[文章2](http://www.cnblogs.com/moodlxs/archive/2012/03/24/2415526.html)\n参考[文章3](http://vim.sourceforge.net/scripts/script.php?script_id=2506)\n参考[文章4](https://zybuluo.com/uuprince/note/81709)\n\n","slug":"Vim技巧","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahf0005pvs68z6n0o9o","content":"<h2 id=\"1-命令快捷键总结\"><a href=\"#1-命令快捷键总结\" class=\"headerlink\" title=\"1 命令快捷键总结\"></a>1 命令快捷键总结</h2><ol>\n<li>Ctrl+z 回到shell，在shell中输入fg回车回到vim</li>\n<li>要同时在多行相同位置插入复制的内容，首先 Ctrl + v 选择位置，然后输入 大写i 进入编辑模式，然后 shift+insert 粘贴，最后Esc退出visual block模式，插入成功</li>\n<li>/xxx 查找xxx，按n/N 跳转到下一个/上一个匹配位置</li>\n<li>:vsp xxx 垂直分割窗口打开xxx<br> :sp xxx 水平分割窗口</li>\n<li>:bn 和 :bp 切换上一个/下一个文件编辑窗口（或者Ctrl+ww）</li>\n<li># 匹配上一个当前单词<br>* 匹配下一个当前单词</li>\n<li>:1, 5 copy 20 将1至5行内容复制到20行位置</li>\n<li>:d5 剪切从当前行开始的5行，用p粘贴到指定行</li>\n<li>dw 剪切当前字符开始的一个词，使用 p 粘贴</li>\n<li>cw 删除当前字符开始的单词，并进入插入模式（相当于替换当前单词内容）</li>\n<li>0 移动到本行最开头<br>$ 移动到本行最尾部<br>w 移动到下一个单词起始字符处<br>e 移动到下一个单词结尾字符处</li>\n<li>% 匹配括号进行移动，可以从 ‘{‘ 移动到对应的 ‘}’，或者反之（首先得保证当前光标在某个半括号上，适用于大中小括号）</li>\n<li>u undo</li>\n<li>Ctrl+r redo</li>\n<li>Ctrl+p/n 自动补全，p表示向上查找匹配词，n表示向下查找；</li>\n<li>:s/xxx/yyy/ 将当前行中的第一个「xxx」替换为「yyy」<br>:s/xxx/yyy/g 将当前行中的所有「xxx」替换为「yyy」<br>:s/xxx/yyy/gc 同上，但每次替换都会询问<br>:%s/xxx/yyy/g 将整个文件中的所有「xxx」替换为「yyy」</li>\n<li>Ctrl+o 回到上一次编辑处<br>Ctrl+i 回到下一次编辑处</li>\n<li>:x 等价于 :wq 等价于 ZZ 保存并退出</li>\n<li>vim -d file1 file2 比较两个文件不同之处</li>\n<li>光标位置移动：<br>a. 保持当前光标位置仅滚动屏幕内容：Ctrl+e/y<br>b. 移动光标到上/下一个历史位置：Ctrl+o/i</li>\n<li>visual、visual行/列模式：<br>a. visual模式：normal模式下按v进入该模式，移动光标可以选中光标首尾的内容；<br>b. visual line模式：即行模式，normal模式下按大写V（或shift+v）进入该模式，移动光标可以选中对应的行；<br>c. visual block模式：即列模式，normal模式下按Ctrl+v进入该模式，移动光标可以选中对应列的内容；</li>\n</ol>\n<h2 id=\"2-ctags-taglist配置使用\"><a href=\"#2-ctags-taglist配置使用\" class=\"headerlink\" title=\"2 ctags/taglist配置使用\"></a>2 ctags/taglist配置使用</h2><p><strong>用途：</strong><br>ctags是一个工具软件，可以为大型项目的源代码生成标签，便于阅读源码时进行跨文件跳转，就像在windows中使用source insight一样，非常方便。</p>\n<p><strong>配置：</strong>  </p>\n<ol>\n<li><p>生成标签文件<br>在项目根目录下执行如下命令：<br>$ctags -R .<br>其中-R表示递归地为当前目录及子目录中所有的源码文件生成标签文件tags，该文件会保存在当前目录下。  </p>\n</li>\n<li><p>使用tag进行跳转<br>1) 用vim打开一个源码文件，随便找到一个变量或者函数调用位置<br>2) 按Ctrl+]可以跳转到该变量/函数定义的位置(可能位于其他文件)，如果有多个文件都包含同名的定义，那么它会以列表形式显示，让你输入编号进行选择<br>3) 按Ctrl+t跳回之前的位置<br>注意：此时打开vim必须在tags文件所在目录，否则会提示找不到tags文件，对于大项目，你可能需要在任意目录下查看源码，这就需要在.vimrc文件中增加一行：<br>set tags=tags;/<br>该命令指示vim在当前目录找不到ctags文件时，自动去上层目录查找。  </p>\n</li>\n<li><p>taglist插件安装<br>taglist是一个vim插件，可以显示源码文件的梗概，如变量、方法列表。安装方法是到www.vim.org中搜索该plugin，然后下载、解压，它会自动解压到 ~/.vim/plugin 中，如果该目录不存在请手动创建。<br>安装完成之后，利用vim打开一个源码文件，然后进入 :命令模式，输入：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">:Tlist</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>即可打开taglist窗口，按F1可以看到操作帮助，为了方便，也可以自己设置打开/关闭taglist的快捷键，比如用F8作为快捷键，则需在.vimrc中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nnoremap &lt;silent&gt; &lt;F8&gt; :TlistToggle&lt;CR&gt;</div></pre></td></tr></table></figure></p>\n<p>这样就可以利用F8打开/关闭taglist了。<br>ctags显示跳转列表需要在vimrc文件中添加一行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set cscopetag</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-vimrc配置-含快捷键\"><a href=\"#3-vimrc配置-含快捷键\" class=\"headerlink\" title=\"3 .vimrc配置(含快捷键)\"></a>3 .vimrc配置(含快捷键)</h2><p>参考<a href=\"http://www.360doc.com/content/13/0111/13/168576_259534618.shtml\" target=\"_blank\" rel=\"external\">文章1</a><br>参考<a href=\"http://www.cnblogs.com/moodlxs/archive/2012/03/24/2415526.html\" target=\"_blank\" rel=\"external\">文章2</a><br>参考<a href=\"http://vim.sourceforge.net/scripts/script.php?script_id=2506\" target=\"_blank\" rel=\"external\">文章3</a><br>参考<a href=\"https://zybuluo.com/uuprince/note/81709\" target=\"_blank\" rel=\"external\">文章4</a></p>\n","excerpt":"","more":"<h2 id=\"1-命令快捷键总结\"><a href=\"#1-命令快捷键总结\" class=\"headerlink\" title=\"1 命令快捷键总结\"></a>1 命令快捷键总结</h2><ol>\n<li>Ctrl+z 回到shell，在shell中输入fg回车回到vim</li>\n<li>要同时在多行相同位置插入复制的内容，首先 Ctrl + v 选择位置，然后输入 大写i 进入编辑模式，然后 shift+insert 粘贴，最后Esc退出visual block模式，插入成功</li>\n<li>/xxx 查找xxx，按n/N 跳转到下一个/上一个匹配位置</li>\n<li>:vsp xxx 垂直分割窗口打开xxx<br> :sp xxx 水平分割窗口</li>\n<li>:bn 和 :bp 切换上一个/下一个文件编辑窗口（或者Ctrl+ww）</li>\n<li># 匹配上一个当前单词<br>* 匹配下一个当前单词</li>\n<li>:1, 5 copy 20 将1至5行内容复制到20行位置</li>\n<li>:d5 剪切从当前行开始的5行，用p粘贴到指定行</li>\n<li>dw 剪切当前字符开始的一个词，使用 p 粘贴</li>\n<li>cw 删除当前字符开始的单词，并进入插入模式（相当于替换当前单词内容）</li>\n<li>0 移动到本行最开头<br>$ 移动到本行最尾部<br>w 移动到下一个单词起始字符处<br>e 移动到下一个单词结尾字符处</li>\n<li>% 匹配括号进行移动，可以从 ‘{‘ 移动到对应的 ‘}’，或者反之（首先得保证当前光标在某个半括号上，适用于大中小括号）</li>\n<li>u undo</li>\n<li>Ctrl+r redo</li>\n<li>Ctrl+p/n 自动补全，p表示向上查找匹配词，n表示向下查找；</li>\n<li>:s/xxx/yyy/ 将当前行中的第一个「xxx」替换为「yyy」<br>:s/xxx/yyy/g 将当前行中的所有「xxx」替换为「yyy」<br>:s/xxx/yyy/gc 同上，但每次替换都会询问<br>:%s/xxx/yyy/g 将整个文件中的所有「xxx」替换为「yyy」</li>\n<li>Ctrl+o 回到上一次编辑处<br>Ctrl+i 回到下一次编辑处</li>\n<li>:x 等价于 :wq 等价于 ZZ 保存并退出</li>\n<li>vim -d file1 file2 比较两个文件不同之处</li>\n<li>光标位置移动：<br>a. 保持当前光标位置仅滚动屏幕内容：Ctrl+e/y<br>b. 移动光标到上/下一个历史位置：Ctrl+o/i</li>\n<li>visual、visual行/列模式：<br>a. visual模式：normal模式下按v进入该模式，移动光标可以选中光标首尾的内容；<br>b. visual line模式：即行模式，normal模式下按大写V（或shift+v）进入该模式，移动光标可以选中对应的行；<br>c. visual block模式：即列模式，normal模式下按Ctrl+v进入该模式，移动光标可以选中对应列的内容；</li>\n</ol>\n<h2 id=\"2-ctags-taglist配置使用\"><a href=\"#2-ctags-taglist配置使用\" class=\"headerlink\" title=\"2 ctags/taglist配置使用\"></a>2 ctags/taglist配置使用</h2><p><strong>用途：</strong><br>ctags是一个工具软件，可以为大型项目的源代码生成标签，便于阅读源码时进行跨文件跳转，就像在windows中使用source insight一样，非常方便。</p>\n<p><strong>配置：</strong>  </p>\n<ol>\n<li><p>生成标签文件<br>在项目根目录下执行如下命令：<br>$ctags -R .<br>其中-R表示递归地为当前目录及子目录中所有的源码文件生成标签文件tags，该文件会保存在当前目录下。  </p>\n</li>\n<li><p>使用tag进行跳转<br>1) 用vim打开一个源码文件，随便找到一个变量或者函数调用位置<br>2) 按Ctrl+]可以跳转到该变量/函数定义的位置(可能位于其他文件)，如果有多个文件都包含同名的定义，那么它会以列表形式显示，让你输入编号进行选择<br>3) 按Ctrl+t跳回之前的位置<br>注意：此时打开vim必须在tags文件所在目录，否则会提示找不到tags文件，对于大项目，你可能需要在任意目录下查看源码，这就需要在.vimrc文件中增加一行：<br>set tags=tags;/<br>该命令指示vim在当前目录找不到ctags文件时，自动去上层目录查找。  </p>\n</li>\n<li><p>taglist插件安装<br>taglist是一个vim插件，可以显示源码文件的梗概，如变量、方法列表。安装方法是到www.vim.org中搜索该plugin，然后下载、解压，它会自动解压到 ~/.vim/plugin 中，如果该目录不存在请手动创建。<br>安装完成之后，利用vim打开一个源码文件，然后进入 :命令模式，输入：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">:Tlist</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>即可打开taglist窗口，按F1可以看到操作帮助，为了方便，也可以自己设置打开/关闭taglist的快捷键，比如用F8作为快捷键，则需在.vimrc中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nnoremap &lt;silent&gt; &lt;F8&gt; :TlistToggle&lt;CR&gt;</div></pre></td></tr></table></figure></p>\n<p>这样就可以利用F8打开/关闭taglist了。<br>ctags显示跳转列表需要在vimrc文件中添加一行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set cscopetag</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-vimrc配置-含快捷键\"><a href=\"#3-vimrc配置-含快捷键\" class=\"headerlink\" title=\"3 .vimrc配置(含快捷键)\"></a>3 .vimrc配置(含快捷键)</h2><p>参考<a href=\"http://www.360doc.com/content/13/0111/13/168576_259534618.shtml\">文章1</a><br>参考<a href=\"http://www.cnblogs.com/moodlxs/archive/2012/03/24/2415526.html\">文章2</a><br>参考<a href=\"http://vim.sourceforge.net/scripts/script.php?script_id=2506\">文章3</a><br>参考<a href=\"https://zybuluo.com/uuprince/note/81709\">文章4</a></p>\n"},{"title":"Paxos算法理解","date":"2017-04-03T07:36:18.000Z","_content":"\n## 一致性算法\n> Paxos算法（Basic Paxos）用来解决分布式环境中多台机器对某个提案/值达成一致的问题。  \n\nPaxos算法中的三个角色：proposer、acceptor、learner。一台机器可以兼任三种角色。  \n注意accept和chosen的区别：  \n- accept：即接受，一个acceptor可以接受任何proposal。\n- chosen：即批准，只有被大多数acceptor所accept的proposal才算被批准。\n\n### 1.1 问题描述\n假设一组进程都可以提出值进行决议，一致性算法保证只有其中一个value被最终选择。如果没有value被proposed，那么就不会选择任何value。如果某个value被chosen了，所有的进程都可以learn到这个value。由此可以得出一致性的安全性（safety）需求如下：  \n\n* 一个value只有被proposed之后才有可能被chosen，\n* 再一次Paxos算法运行实例中，只有一个value最终会被chosen，并且\n* learner只能获取到被chosen的value。\n\n除了safety，还需要保证progress，后面将会讨论。  \n算法的作者Lamport在论文中不断地加强上述三个约束（关键是第二个）最终提出了Paxos算法。  \n\n### 1.2 value的决策\n决策一个值最简单的方式就是只设置一个acceptor，这样一个proposer发送proposal给这个acceptor，然后acceptor总是会选择它所接收到的第一个value（proposal中会指定value）。这是最simple的方法，但是它不能满足要求，因为acceptor存在单点故障。  \n因此，更进一步，我们设置多个acceptor，一个proposer提出一个value给acceptor，一个acceptor可能会接受这个value。只有当大多数acceptor都接受这个value时才算它被chosen，大多数的意思通常是超过半数的参与者，因为任何。两个大多数集合一定至少有一个公共的参与者，这样当一个acceptor最多只能接受一个value时保证大多数能够达成一致。  \n这种方式可以在只有一个proposer且该proposer只提出一个value请求决策的前提下能够正常工作。  \n这种情况下，一致性算法要想能够工作，暗含如下约束：  \n\n> P1. 一个acceptor必须接受它收到的第一个value。\n\n这个约束显然是有问题的，因为多个proposer可能在相同时刻提出多个不同的value，这会导致虽然每个acceptor都接受了一个value，但是并没有某个value被大多数acceptor所接受。例如假设有两个value分别被一半的acceptor接受，那么最终无法达成一致。  \nP1的约束暗示一个acceptor必须能够接受多个proposal。我们利用不同的编号来跟踪不同的proposal，这样每个proposal包含一个唯一的编号和一个值。这样一个value被chosen也就表示其所属的proposal被大多数acceptor所接受。  \n我们允许有多个proposal被依次chosen的情况发生（后面的proposal编号更高），但是必须保证这多个proposal都包含相同的value，这样需要如下约束：  \n\n> P2. 如果一个带有值v的proposal被chosen，那么每个被chosen的具备更高编号的proposal都具有值v。\n\nproposal的编号都是有序的，后面的会比前面的编号更高。   \nP2可以保证safety约束的第二条：只有一个value会被chosen。  \n要想被chosen，一个proposal必须至少被一个acceptor接受，因此，我们可以用P2a来满足P2：  \n\n> P2a. 如果一个带有值v的proposal被chosen了，那么后续每个acceptor所accept（注意是accept，而不是chosen，单个acceptor可以accept任何proposal，被大多数acceptor所accept得proposal才叫chosen）的每个具备更高编号的proposal都必须具备值v。\n\n我们依然需要满足P1来保证某个proposal被chosen。但是由于通信是异步的，P2a可能与P1发生冲突，考虑这种情况：一个值为v的proposal被chosen了，说明它被大多数acceptor所accept，但是依然存在少部分acceptor没有收到这个proposal，此时如果一个新的proposer苏醒并提出一个更高编号的值不是v的proposal发给这些少部分acceptor，那么根据P1的约束，这些acceptor一定会accept这个新的proposal，这就违背了P2a约束。  \n\n要想保持P1和P2a，就需要进一步加强P2a：  \n> p2b. 如果一个值为v的proposal被chosen了，后续被任何proposer提出的更高编号的proposal的值都必须是v。\n\n由于一个proposal一定是先被某个proposer提出，然后才能被acceptor接受，最后才能被批准。P2b比P2a时序更早，从accept阶段提前到了issue阶段，因此满足P2b一定能满足P2a，从而满足P2约束。  \n如何满足P2b？我们进一步提出P2c：  \n> P2c. 对于任意的值v和编号n，如果一个带有值v编号为n的proposal被提出，那么一定有一个多数参与者集合S满足：（a）S中不存在acceptor已经accept任何编号小于n的proposal，或者（b）S中的acceptor所接受的proposal中编号最高的具备值v。\n\n我们可以利用数学归纳法证明P2c蕴含P2b：  \n假设具备值v编号为m的proposal已经被chosen，当n=m+1时，利用反证法，如果proposal n的值不是v，而是w，根据P2c，一定存在一个多数派S满足：（1）S中的所有acceptor都没有accept过任何编号小于n的proposal，这一点显然不满足，因为S与接收过m提案的集合C一定至少有一个公共成员，显然该成员accept了提案m；（2）S中的acceptor所接受的提案中编号最高的具备值w，这一条也不满足，因为m的值是v。所以假设不成立，当n=m+1时，提案n的值与提案m相同，为v。  \n推广到更大的n，对于提案m+1…n-1，根据如上假设，它们都具备值v，假设提案n的值为x，不等于v，那么根据P2c约束，一定存在一个多数派S2，满足：（1）要么它们没有接受过任何编号小于n的任何提案，这一点显然也不满足，因为提案m…n-1已经被chosen了；（2）要么它们accept的提案中编号最大的具备值x，而如果v不等于x，显然也不满足。因此，提案n的值一定是v。  \n得证。  \n因此P2c蕴含P2b。  \n\nP2c这个约束可以通过消息传递程序进行实现。  \n根据P2c的约束内容可以得出，proposer在正式提出一个proposal之前，一定要先和大多数acceptor进行通信，得到它们之前投票的情况，根据回复的信息来设置proposal的value，然后开始投票过程，当得到大多数acceptor接受之后，提案获得通过，然后再通知learner即可。  \n由于现实环境中，多条消息可能并发到达某个acceptor，因此可能存在这种情况：某个acceptor还没有accept过任何proposal，此时它回复了编号为n的proposal自己的情况（prepare阶段），但是在对n进行表决（accept阶段）之前，它收到了编号更小为m的另一个提案的accept请求，由于此时它还没有accept提案n，因此它接受了m提案，如果提案m和n的值不一样，那么这就违背了P2c约束，因为时间原因它没有回复给n它所accept的提案m的value。  \n预防这个问题发生的方法是：acceptor给proposer第一次应答的同时保证自己不会accept编号更小的提案。这也是对P1约束的加强：  \n> P1a. 一个acceptor可以accept编号为n的proposal当且仅当它没有回复过编号大于n的proposal的prepare请求。\n\n至此，P1a和P2c约束已经足够完备，是时候提出完整的Paxos算法了。\n\n\n### 1.3 Paxos算法内容\nPaxos算法分为两个阶段：prepare阶段和accept阶段。\n\n#### 1. prepare阶段：\na. proposer选择一个提案编号n，并利用它构造一个prepare请求发给一个包含大多数acceptor的集合。  \nb. 如果一个acceptor编号为n的prepare请求，且n大于它已经回应过的任何一个prepare请求的编号，那么它将把它所accept过的最大编号的提案作为回复，同时承诺不再accept任何编号小于n的proposal。\n\n#### 2. accept阶段：\na. 如果proposer收到了大多数acceptor对其发出的prepare请求的回复，那么它将发送提案n的accept请求给这些acceptor，该请求中包含的值v要么是回复中的此前编号最高proposal的值，要么是该proposer自定义的值（当前者不存在时）。  \nb. acceptor将接受提案n的accept请求，除非它已经回复了一个编号更高的proposal的prepare请求。  \n\n### 1.4 算法的Progress保证\n存在这样一种情况：两个proposer不断提出编号比对方高的提案，这样会进入活锁状态，永远不会有提案获得批准。算法也就不能向前推进。\n为了解决这个问题，确保算法能够progress，必须选出一个主proposer，且只有它能够提出提案，这样就能保证算法的正常执行。  \n如果分布式系统能够正常运行，那么主proposer的方案使得系统的liveness（响应、活跃度）也能得到保证。  \n\n## 2 算法扩展\n基本的Paxos算法称为Basic Paxos，它允许多个proposer同时提出提案。本算法的一个变种是Mutility Paxos，它通过利用单个主proposer同时向多个Paxos实例发出prepare请求，在后续的决议过程中直接跳过prepare阶段，直接执行accept阶段，提高算法的运行效率。之所以可以跳过prepare阶段，是因为采用了单一proposer，且只有该proposer负责提出议案，议案编号也由它生成，可以保证不存在prepare阶段中可能存在的冲突，不再需要通过prepare阶段来检测冲突。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Paxos算法理解.md","raw":"---\ntitle: Paxos算法理解\ndate: 2017-04-03 15:36:18\ntags: Paxos\n---\n\n## 一致性算法\n> Paxos算法（Basic Paxos）用来解决分布式环境中多台机器对某个提案/值达成一致的问题。  \n\nPaxos算法中的三个角色：proposer、acceptor、learner。一台机器可以兼任三种角色。  \n注意accept和chosen的区别：  \n- accept：即接受，一个acceptor可以接受任何proposal。\n- chosen：即批准，只有被大多数acceptor所accept的proposal才算被批准。\n\n### 1.1 问题描述\n假设一组进程都可以提出值进行决议，一致性算法保证只有其中一个value被最终选择。如果没有value被proposed，那么就不会选择任何value。如果某个value被chosen了，所有的进程都可以learn到这个value。由此可以得出一致性的安全性（safety）需求如下：  \n\n* 一个value只有被proposed之后才有可能被chosen，\n* 再一次Paxos算法运行实例中，只有一个value最终会被chosen，并且\n* learner只能获取到被chosen的value。\n\n除了safety，还需要保证progress，后面将会讨论。  \n算法的作者Lamport在论文中不断地加强上述三个约束（关键是第二个）最终提出了Paxos算法。  \n\n### 1.2 value的决策\n决策一个值最简单的方式就是只设置一个acceptor，这样一个proposer发送proposal给这个acceptor，然后acceptor总是会选择它所接收到的第一个value（proposal中会指定value）。这是最simple的方法，但是它不能满足要求，因为acceptor存在单点故障。  \n因此，更进一步，我们设置多个acceptor，一个proposer提出一个value给acceptor，一个acceptor可能会接受这个value。只有当大多数acceptor都接受这个value时才算它被chosen，大多数的意思通常是超过半数的参与者，因为任何。两个大多数集合一定至少有一个公共的参与者，这样当一个acceptor最多只能接受一个value时保证大多数能够达成一致。  \n这种方式可以在只有一个proposer且该proposer只提出一个value请求决策的前提下能够正常工作。  \n这种情况下，一致性算法要想能够工作，暗含如下约束：  \n\n> P1. 一个acceptor必须接受它收到的第一个value。\n\n这个约束显然是有问题的，因为多个proposer可能在相同时刻提出多个不同的value，这会导致虽然每个acceptor都接受了一个value，但是并没有某个value被大多数acceptor所接受。例如假设有两个value分别被一半的acceptor接受，那么最终无法达成一致。  \nP1的约束暗示一个acceptor必须能够接受多个proposal。我们利用不同的编号来跟踪不同的proposal，这样每个proposal包含一个唯一的编号和一个值。这样一个value被chosen也就表示其所属的proposal被大多数acceptor所接受。  \n我们允许有多个proposal被依次chosen的情况发生（后面的proposal编号更高），但是必须保证这多个proposal都包含相同的value，这样需要如下约束：  \n\n> P2. 如果一个带有值v的proposal被chosen，那么每个被chosen的具备更高编号的proposal都具有值v。\n\nproposal的编号都是有序的，后面的会比前面的编号更高。   \nP2可以保证safety约束的第二条：只有一个value会被chosen。  \n要想被chosen，一个proposal必须至少被一个acceptor接受，因此，我们可以用P2a来满足P2：  \n\n> P2a. 如果一个带有值v的proposal被chosen了，那么后续每个acceptor所accept（注意是accept，而不是chosen，单个acceptor可以accept任何proposal，被大多数acceptor所accept得proposal才叫chosen）的每个具备更高编号的proposal都必须具备值v。\n\n我们依然需要满足P1来保证某个proposal被chosen。但是由于通信是异步的，P2a可能与P1发生冲突，考虑这种情况：一个值为v的proposal被chosen了，说明它被大多数acceptor所accept，但是依然存在少部分acceptor没有收到这个proposal，此时如果一个新的proposer苏醒并提出一个更高编号的值不是v的proposal发给这些少部分acceptor，那么根据P1的约束，这些acceptor一定会accept这个新的proposal，这就违背了P2a约束。  \n\n要想保持P1和P2a，就需要进一步加强P2a：  \n> p2b. 如果一个值为v的proposal被chosen了，后续被任何proposer提出的更高编号的proposal的值都必须是v。\n\n由于一个proposal一定是先被某个proposer提出，然后才能被acceptor接受，最后才能被批准。P2b比P2a时序更早，从accept阶段提前到了issue阶段，因此满足P2b一定能满足P2a，从而满足P2约束。  \n如何满足P2b？我们进一步提出P2c：  \n> P2c. 对于任意的值v和编号n，如果一个带有值v编号为n的proposal被提出，那么一定有一个多数参与者集合S满足：（a）S中不存在acceptor已经accept任何编号小于n的proposal，或者（b）S中的acceptor所接受的proposal中编号最高的具备值v。\n\n我们可以利用数学归纳法证明P2c蕴含P2b：  \n假设具备值v编号为m的proposal已经被chosen，当n=m+1时，利用反证法，如果proposal n的值不是v，而是w，根据P2c，一定存在一个多数派S满足：（1）S中的所有acceptor都没有accept过任何编号小于n的proposal，这一点显然不满足，因为S与接收过m提案的集合C一定至少有一个公共成员，显然该成员accept了提案m；（2）S中的acceptor所接受的提案中编号最高的具备值w，这一条也不满足，因为m的值是v。所以假设不成立，当n=m+1时，提案n的值与提案m相同，为v。  \n推广到更大的n，对于提案m+1…n-1，根据如上假设，它们都具备值v，假设提案n的值为x，不等于v，那么根据P2c约束，一定存在一个多数派S2，满足：（1）要么它们没有接受过任何编号小于n的任何提案，这一点显然也不满足，因为提案m…n-1已经被chosen了；（2）要么它们accept的提案中编号最大的具备值x，而如果v不等于x，显然也不满足。因此，提案n的值一定是v。  \n得证。  \n因此P2c蕴含P2b。  \n\nP2c这个约束可以通过消息传递程序进行实现。  \n根据P2c的约束内容可以得出，proposer在正式提出一个proposal之前，一定要先和大多数acceptor进行通信，得到它们之前投票的情况，根据回复的信息来设置proposal的value，然后开始投票过程，当得到大多数acceptor接受之后，提案获得通过，然后再通知learner即可。  \n由于现实环境中，多条消息可能并发到达某个acceptor，因此可能存在这种情况：某个acceptor还没有accept过任何proposal，此时它回复了编号为n的proposal自己的情况（prepare阶段），但是在对n进行表决（accept阶段）之前，它收到了编号更小为m的另一个提案的accept请求，由于此时它还没有accept提案n，因此它接受了m提案，如果提案m和n的值不一样，那么这就违背了P2c约束，因为时间原因它没有回复给n它所accept的提案m的value。  \n预防这个问题发生的方法是：acceptor给proposer第一次应答的同时保证自己不会accept编号更小的提案。这也是对P1约束的加强：  \n> P1a. 一个acceptor可以accept编号为n的proposal当且仅当它没有回复过编号大于n的proposal的prepare请求。\n\n至此，P1a和P2c约束已经足够完备，是时候提出完整的Paxos算法了。\n\n\n### 1.3 Paxos算法内容\nPaxos算法分为两个阶段：prepare阶段和accept阶段。\n\n#### 1. prepare阶段：\na. proposer选择一个提案编号n，并利用它构造一个prepare请求发给一个包含大多数acceptor的集合。  \nb. 如果一个acceptor编号为n的prepare请求，且n大于它已经回应过的任何一个prepare请求的编号，那么它将把它所accept过的最大编号的提案作为回复，同时承诺不再accept任何编号小于n的proposal。\n\n#### 2. accept阶段：\na. 如果proposer收到了大多数acceptor对其发出的prepare请求的回复，那么它将发送提案n的accept请求给这些acceptor，该请求中包含的值v要么是回复中的此前编号最高proposal的值，要么是该proposer自定义的值（当前者不存在时）。  \nb. acceptor将接受提案n的accept请求，除非它已经回复了一个编号更高的proposal的prepare请求。  \n\n### 1.4 算法的Progress保证\n存在这样一种情况：两个proposer不断提出编号比对方高的提案，这样会进入活锁状态，永远不会有提案获得批准。算法也就不能向前推进。\n为了解决这个问题，确保算法能够progress，必须选出一个主proposer，且只有它能够提出提案，这样就能保证算法的正常执行。  \n如果分布式系统能够正常运行，那么主proposer的方案使得系统的liveness（响应、活跃度）也能得到保证。  \n\n## 2 算法扩展\n基本的Paxos算法称为Basic Paxos，它允许多个proposer同时提出提案。本算法的一个变种是Mutility Paxos，它通过利用单个主proposer同时向多个Paxos实例发出prepare请求，在后续的决议过程中直接跳过prepare阶段，直接执行accept阶段，提高算法的运行效率。之所以可以跳过prepare阶段，是因为采用了单一proposer，且只有该proposer负责提出议案，议案编号也由它生成，可以保证不存在prepare阶段中可能存在的冲突，不再需要通过prepare阶段来检测冲突。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Paxos算法理解","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahi0006pvs6az4667fc","content":"<h2 id=\"一致性算法\"><a href=\"#一致性算法\" class=\"headerlink\" title=\"一致性算法\"></a>一致性算法</h2><blockquote>\n<p>Paxos算法（Basic Paxos）用来解决分布式环境中多台机器对某个提案/值达成一致的问题。  </p>\n</blockquote>\n<p>Paxos算法中的三个角色：proposer、acceptor、learner。一台机器可以兼任三种角色。<br>注意accept和chosen的区别：  </p>\n<ul>\n<li>accept：即接受，一个acceptor可以接受任何proposal。</li>\n<li>chosen：即批准，只有被大多数acceptor所accept的proposal才算被批准。</li>\n</ul>\n<h3 id=\"1-1-问题描述\"><a href=\"#1-1-问题描述\" class=\"headerlink\" title=\"1.1 问题描述\"></a>1.1 问题描述</h3><p>假设一组进程都可以提出值进行决议，一致性算法保证只有其中一个value被最终选择。如果没有value被proposed，那么就不会选择任何value。如果某个value被chosen了，所有的进程都可以learn到这个value。由此可以得出一致性的安全性（safety）需求如下：  </p>\n<ul>\n<li>一个value只有被proposed之后才有可能被chosen，</li>\n<li>再一次Paxos算法运行实例中，只有一个value最终会被chosen，并且</li>\n<li>learner只能获取到被chosen的value。</li>\n</ul>\n<p>除了safety，还需要保证progress，后面将会讨论。<br>算法的作者Lamport在论文中不断地加强上述三个约束（关键是第二个）最终提出了Paxos算法。  </p>\n<h3 id=\"1-2-value的决策\"><a href=\"#1-2-value的决策\" class=\"headerlink\" title=\"1.2 value的决策\"></a>1.2 value的决策</h3><p>决策一个值最简单的方式就是只设置一个acceptor，这样一个proposer发送proposal给这个acceptor，然后acceptor总是会选择它所接收到的第一个value（proposal中会指定value）。这是最simple的方法，但是它不能满足要求，因为acceptor存在单点故障。<br>因此，更进一步，我们设置多个acceptor，一个proposer提出一个value给acceptor，一个acceptor可能会接受这个value。只有当大多数acceptor都接受这个value时才算它被chosen，大多数的意思通常是超过半数的参与者，因为任何。两个大多数集合一定至少有一个公共的参与者，这样当一个acceptor最多只能接受一个value时保证大多数能够达成一致。<br>这种方式可以在只有一个proposer且该proposer只提出一个value请求决策的前提下能够正常工作。<br>这种情况下，一致性算法要想能够工作，暗含如下约束：  </p>\n<blockquote>\n<p>P1. 一个acceptor必须接受它收到的第一个value。</p>\n</blockquote>\n<p>这个约束显然是有问题的，因为多个proposer可能在相同时刻提出多个不同的value，这会导致虽然每个acceptor都接受了一个value，但是并没有某个value被大多数acceptor所接受。例如假设有两个value分别被一半的acceptor接受，那么最终无法达成一致。<br>P1的约束暗示一个acceptor必须能够接受多个proposal。我们利用不同的编号来跟踪不同的proposal，这样每个proposal包含一个唯一的编号和一个值。这样一个value被chosen也就表示其所属的proposal被大多数acceptor所接受。<br>我们允许有多个proposal被依次chosen的情况发生（后面的proposal编号更高），但是必须保证这多个proposal都包含相同的value，这样需要如下约束：  </p>\n<blockquote>\n<p>P2. 如果一个带有值v的proposal被chosen，那么每个被chosen的具备更高编号的proposal都具有值v。</p>\n</blockquote>\n<p>proposal的编号都是有序的，后面的会比前面的编号更高。<br>P2可以保证safety约束的第二条：只有一个value会被chosen。<br>要想被chosen，一个proposal必须至少被一个acceptor接受，因此，我们可以用P2a来满足P2：  </p>\n<blockquote>\n<p>P2a. 如果一个带有值v的proposal被chosen了，那么后续每个acceptor所accept（注意是accept，而不是chosen，单个acceptor可以accept任何proposal，被大多数acceptor所accept得proposal才叫chosen）的每个具备更高编号的proposal都必须具备值v。</p>\n</blockquote>\n<p>我们依然需要满足P1来保证某个proposal被chosen。但是由于通信是异步的，P2a可能与P1发生冲突，考虑这种情况：一个值为v的proposal被chosen了，说明它被大多数acceptor所accept，但是依然存在少部分acceptor没有收到这个proposal，此时如果一个新的proposer苏醒并提出一个更高编号的值不是v的proposal发给这些少部分acceptor，那么根据P1的约束，这些acceptor一定会accept这个新的proposal，这就违背了P2a约束。  </p>\n<p>要想保持P1和P2a，就需要进一步加强P2a：  </p>\n<blockquote>\n<p>p2b. 如果一个值为v的proposal被chosen了，后续被任何proposer提出的更高编号的proposal的值都必须是v。</p>\n</blockquote>\n<p>由于一个proposal一定是先被某个proposer提出，然后才能被acceptor接受，最后才能被批准。P2b比P2a时序更早，从accept阶段提前到了issue阶段，因此满足P2b一定能满足P2a，从而满足P2约束。<br>如何满足P2b？我们进一步提出P2c：  </p>\n<blockquote>\n<p>P2c. 对于任意的值v和编号n，如果一个带有值v编号为n的proposal被提出，那么一定有一个多数参与者集合S满足：（a）S中不存在acceptor已经accept任何编号小于n的proposal，或者（b）S中的acceptor所接受的proposal中编号最高的具备值v。</p>\n</blockquote>\n<p>我们可以利用数学归纳法证明P2c蕴含P2b：<br>假设具备值v编号为m的proposal已经被chosen，当n=m+1时，利用反证法，如果proposal n的值不是v，而是w，根据P2c，一定存在一个多数派S满足：（1）S中的所有acceptor都没有accept过任何编号小于n的proposal，这一点显然不满足，因为S与接收过m提案的集合C一定至少有一个公共成员，显然该成员accept了提案m；（2）S中的acceptor所接受的提案中编号最高的具备值w，这一条也不满足，因为m的值是v。所以假设不成立，当n=m+1时，提案n的值与提案m相同，为v。<br>推广到更大的n，对于提案m+1…n-1，根据如上假设，它们都具备值v，假设提案n的值为x，不等于v，那么根据P2c约束，一定存在一个多数派S2，满足：（1）要么它们没有接受过任何编号小于n的任何提案，这一点显然也不满足，因为提案m…n-1已经被chosen了；（2）要么它们accept的提案中编号最大的具备值x，而如果v不等于x，显然也不满足。因此，提案n的值一定是v。<br>得证。<br>因此P2c蕴含P2b。  </p>\n<p>P2c这个约束可以通过消息传递程序进行实现。<br>根据P2c的约束内容可以得出，proposer在正式提出一个proposal之前，一定要先和大多数acceptor进行通信，得到它们之前投票的情况，根据回复的信息来设置proposal的value，然后开始投票过程，当得到大多数acceptor接受之后，提案获得通过，然后再通知learner即可。<br>由于现实环境中，多条消息可能并发到达某个acceptor，因此可能存在这种情况：某个acceptor还没有accept过任何proposal，此时它回复了编号为n的proposal自己的情况（prepare阶段），但是在对n进行表决（accept阶段）之前，它收到了编号更小为m的另一个提案的accept请求，由于此时它还没有accept提案n，因此它接受了m提案，如果提案m和n的值不一样，那么这就违背了P2c约束，因为时间原因它没有回复给n它所accept的提案m的value。<br>预防这个问题发生的方法是：acceptor给proposer第一次应答的同时保证自己不会accept编号更小的提案。这也是对P1约束的加强：  </p>\n<blockquote>\n<p>P1a. 一个acceptor可以accept编号为n的proposal当且仅当它没有回复过编号大于n的proposal的prepare请求。</p>\n</blockquote>\n<p>至此，P1a和P2c约束已经足够完备，是时候提出完整的Paxos算法了。</p>\n<h3 id=\"1-3-Paxos算法内容\"><a href=\"#1-3-Paxos算法内容\" class=\"headerlink\" title=\"1.3 Paxos算法内容\"></a>1.3 Paxos算法内容</h3><p>Paxos算法分为两个阶段：prepare阶段和accept阶段。</p>\n<h4 id=\"1-prepare阶段：\"><a href=\"#1-prepare阶段：\" class=\"headerlink\" title=\"1. prepare阶段：\"></a>1. prepare阶段：</h4><p>a. proposer选择一个提案编号n，并利用它构造一个prepare请求发给一个包含大多数acceptor的集合。<br>b. 如果一个acceptor编号为n的prepare请求，且n大于它已经回应过的任何一个prepare请求的编号，那么它将把它所accept过的最大编号的提案作为回复，同时承诺不再accept任何编号小于n的proposal。</p>\n<h4 id=\"2-accept阶段：\"><a href=\"#2-accept阶段：\" class=\"headerlink\" title=\"2. accept阶段：\"></a>2. accept阶段：</h4><p>a. 如果proposer收到了大多数acceptor对其发出的prepare请求的回复，那么它将发送提案n的accept请求给这些acceptor，该请求中包含的值v要么是回复中的此前编号最高proposal的值，要么是该proposer自定义的值（当前者不存在时）。<br>b. acceptor将接受提案n的accept请求，除非它已经回复了一个编号更高的proposal的prepare请求。  </p>\n<h3 id=\"1-4-算法的Progress保证\"><a href=\"#1-4-算法的Progress保证\" class=\"headerlink\" title=\"1.4 算法的Progress保证\"></a>1.4 算法的Progress保证</h3><p>存在这样一种情况：两个proposer不断提出编号比对方高的提案，这样会进入活锁状态，永远不会有提案获得批准。算法也就不能向前推进。<br>为了解决这个问题，确保算法能够progress，必须选出一个主proposer，且只有它能够提出提案，这样就能保证算法的正常执行。<br>如果分布式系统能够正常运行，那么主proposer的方案使得系统的liveness（响应、活跃度）也能得到保证。  </p>\n<h2 id=\"2-算法扩展\"><a href=\"#2-算法扩展\" class=\"headerlink\" title=\"2 算法扩展\"></a>2 算法扩展</h2><p>基本的Paxos算法称为Basic Paxos，它允许多个proposer同时提出提案。本算法的一个变种是Mutility Paxos，它通过利用单个主proposer同时向多个Paxos实例发出prepare请求，在后续的决议过程中直接跳过prepare阶段，直接执行accept阶段，提高算法的运行效率。之所以可以跳过prepare阶段，是因为采用了单一proposer，且只有该proposer负责提出议案，议案编号也由它生成，可以保证不存在prepare阶段中可能存在的冲突，不再需要通过prepare阶段来检测冲突。</p>\n","excerpt":"","more":"<h2 id=\"一致性算法\"><a href=\"#一致性算法\" class=\"headerlink\" title=\"一致性算法\"></a>一致性算法</h2><blockquote>\n<p>Paxos算法（Basic Paxos）用来解决分布式环境中多台机器对某个提案/值达成一致的问题。  </p>\n</blockquote>\n<p>Paxos算法中的三个角色：proposer、acceptor、learner。一台机器可以兼任三种角色。<br>注意accept和chosen的区别：  </p>\n<ul>\n<li>accept：即接受，一个acceptor可以接受任何proposal。</li>\n<li>chosen：即批准，只有被大多数acceptor所accept的proposal才算被批准。</li>\n</ul>\n<h3 id=\"1-1-问题描述\"><a href=\"#1-1-问题描述\" class=\"headerlink\" title=\"1.1 问题描述\"></a>1.1 问题描述</h3><p>假设一组进程都可以提出值进行决议，一致性算法保证只有其中一个value被最终选择。如果没有value被proposed，那么就不会选择任何value。如果某个value被chosen了，所有的进程都可以learn到这个value。由此可以得出一致性的安全性（safety）需求如下：  </p>\n<ul>\n<li>一个value只有被proposed之后才有可能被chosen，</li>\n<li>再一次Paxos算法运行实例中，只有一个value最终会被chosen，并且</li>\n<li>learner只能获取到被chosen的value。</li>\n</ul>\n<p>除了safety，还需要保证progress，后面将会讨论。<br>算法的作者Lamport在论文中不断地加强上述三个约束（关键是第二个）最终提出了Paxos算法。  </p>\n<h3 id=\"1-2-value的决策\"><a href=\"#1-2-value的决策\" class=\"headerlink\" title=\"1.2 value的决策\"></a>1.2 value的决策</h3><p>决策一个值最简单的方式就是只设置一个acceptor，这样一个proposer发送proposal给这个acceptor，然后acceptor总是会选择它所接收到的第一个value（proposal中会指定value）。这是最simple的方法，但是它不能满足要求，因为acceptor存在单点故障。<br>因此，更进一步，我们设置多个acceptor，一个proposer提出一个value给acceptor，一个acceptor可能会接受这个value。只有当大多数acceptor都接受这个value时才算它被chosen，大多数的意思通常是超过半数的参与者，因为任何。两个大多数集合一定至少有一个公共的参与者，这样当一个acceptor最多只能接受一个value时保证大多数能够达成一致。<br>这种方式可以在只有一个proposer且该proposer只提出一个value请求决策的前提下能够正常工作。<br>这种情况下，一致性算法要想能够工作，暗含如下约束：  </p>\n<blockquote>\n<p>P1. 一个acceptor必须接受它收到的第一个value。</p>\n</blockquote>\n<p>这个约束显然是有问题的，因为多个proposer可能在相同时刻提出多个不同的value，这会导致虽然每个acceptor都接受了一个value，但是并没有某个value被大多数acceptor所接受。例如假设有两个value分别被一半的acceptor接受，那么最终无法达成一致。<br>P1的约束暗示一个acceptor必须能够接受多个proposal。我们利用不同的编号来跟踪不同的proposal，这样每个proposal包含一个唯一的编号和一个值。这样一个value被chosen也就表示其所属的proposal被大多数acceptor所接受。<br>我们允许有多个proposal被依次chosen的情况发生（后面的proposal编号更高），但是必须保证这多个proposal都包含相同的value，这样需要如下约束：  </p>\n<blockquote>\n<p>P2. 如果一个带有值v的proposal被chosen，那么每个被chosen的具备更高编号的proposal都具有值v。</p>\n</blockquote>\n<p>proposal的编号都是有序的，后面的会比前面的编号更高。<br>P2可以保证safety约束的第二条：只有一个value会被chosen。<br>要想被chosen，一个proposal必须至少被一个acceptor接受，因此，我们可以用P2a来满足P2：  </p>\n<blockquote>\n<p>P2a. 如果一个带有值v的proposal被chosen了，那么后续每个acceptor所accept（注意是accept，而不是chosen，单个acceptor可以accept任何proposal，被大多数acceptor所accept得proposal才叫chosen）的每个具备更高编号的proposal都必须具备值v。</p>\n</blockquote>\n<p>我们依然需要满足P1来保证某个proposal被chosen。但是由于通信是异步的，P2a可能与P1发生冲突，考虑这种情况：一个值为v的proposal被chosen了，说明它被大多数acceptor所accept，但是依然存在少部分acceptor没有收到这个proposal，此时如果一个新的proposer苏醒并提出一个更高编号的值不是v的proposal发给这些少部分acceptor，那么根据P1的约束，这些acceptor一定会accept这个新的proposal，这就违背了P2a约束。  </p>\n<p>要想保持P1和P2a，就需要进一步加强P2a：  </p>\n<blockquote>\n<p>p2b. 如果一个值为v的proposal被chosen了，后续被任何proposer提出的更高编号的proposal的值都必须是v。</p>\n</blockquote>\n<p>由于一个proposal一定是先被某个proposer提出，然后才能被acceptor接受，最后才能被批准。P2b比P2a时序更早，从accept阶段提前到了issue阶段，因此满足P2b一定能满足P2a，从而满足P2约束。<br>如何满足P2b？我们进一步提出P2c：  </p>\n<blockquote>\n<p>P2c. 对于任意的值v和编号n，如果一个带有值v编号为n的proposal被提出，那么一定有一个多数参与者集合S满足：（a）S中不存在acceptor已经accept任何编号小于n的proposal，或者（b）S中的acceptor所接受的proposal中编号最高的具备值v。</p>\n</blockquote>\n<p>我们可以利用数学归纳法证明P2c蕴含P2b：<br>假设具备值v编号为m的proposal已经被chosen，当n=m+1时，利用反证法，如果proposal n的值不是v，而是w，根据P2c，一定存在一个多数派S满足：（1）S中的所有acceptor都没有accept过任何编号小于n的proposal，这一点显然不满足，因为S与接收过m提案的集合C一定至少有一个公共成员，显然该成员accept了提案m；（2）S中的acceptor所接受的提案中编号最高的具备值w，这一条也不满足，因为m的值是v。所以假设不成立，当n=m+1时，提案n的值与提案m相同，为v。<br>推广到更大的n，对于提案m+1…n-1，根据如上假设，它们都具备值v，假设提案n的值为x，不等于v，那么根据P2c约束，一定存在一个多数派S2，满足：（1）要么它们没有接受过任何编号小于n的任何提案，这一点显然也不满足，因为提案m…n-1已经被chosen了；（2）要么它们accept的提案中编号最大的具备值x，而如果v不等于x，显然也不满足。因此，提案n的值一定是v。<br>得证。<br>因此P2c蕴含P2b。  </p>\n<p>P2c这个约束可以通过消息传递程序进行实现。<br>根据P2c的约束内容可以得出，proposer在正式提出一个proposal之前，一定要先和大多数acceptor进行通信，得到它们之前投票的情况，根据回复的信息来设置proposal的value，然后开始投票过程，当得到大多数acceptor接受之后，提案获得通过，然后再通知learner即可。<br>由于现实环境中，多条消息可能并发到达某个acceptor，因此可能存在这种情况：某个acceptor还没有accept过任何proposal，此时它回复了编号为n的proposal自己的情况（prepare阶段），但是在对n进行表决（accept阶段）之前，它收到了编号更小为m的另一个提案的accept请求，由于此时它还没有accept提案n，因此它接受了m提案，如果提案m和n的值不一样，那么这就违背了P2c约束，因为时间原因它没有回复给n它所accept的提案m的value。<br>预防这个问题发生的方法是：acceptor给proposer第一次应答的同时保证自己不会accept编号更小的提案。这也是对P1约束的加强：  </p>\n<blockquote>\n<p>P1a. 一个acceptor可以accept编号为n的proposal当且仅当它没有回复过编号大于n的proposal的prepare请求。</p>\n</blockquote>\n<p>至此，P1a和P2c约束已经足够完备，是时候提出完整的Paxos算法了。</p>\n<h3 id=\"1-3-Paxos算法内容\"><a href=\"#1-3-Paxos算法内容\" class=\"headerlink\" title=\"1.3 Paxos算法内容\"></a>1.3 Paxos算法内容</h3><p>Paxos算法分为两个阶段：prepare阶段和accept阶段。</p>\n<h4 id=\"1-prepare阶段：\"><a href=\"#1-prepare阶段：\" class=\"headerlink\" title=\"1. prepare阶段：\"></a>1. prepare阶段：</h4><p>a. proposer选择一个提案编号n，并利用它构造一个prepare请求发给一个包含大多数acceptor的集合。<br>b. 如果一个acceptor编号为n的prepare请求，且n大于它已经回应过的任何一个prepare请求的编号，那么它将把它所accept过的最大编号的提案作为回复，同时承诺不再accept任何编号小于n的proposal。</p>\n<h4 id=\"2-accept阶段：\"><a href=\"#2-accept阶段：\" class=\"headerlink\" title=\"2. accept阶段：\"></a>2. accept阶段：</h4><p>a. 如果proposer收到了大多数acceptor对其发出的prepare请求的回复，那么它将发送提案n的accept请求给这些acceptor，该请求中包含的值v要么是回复中的此前编号最高proposal的值，要么是该proposer自定义的值（当前者不存在时）。<br>b. acceptor将接受提案n的accept请求，除非它已经回复了一个编号更高的proposal的prepare请求。  </p>\n<h3 id=\"1-4-算法的Progress保证\"><a href=\"#1-4-算法的Progress保证\" class=\"headerlink\" title=\"1.4 算法的Progress保证\"></a>1.4 算法的Progress保证</h3><p>存在这样一种情况：两个proposer不断提出编号比对方高的提案，这样会进入活锁状态，永远不会有提案获得批准。算法也就不能向前推进。<br>为了解决这个问题，确保算法能够progress，必须选出一个主proposer，且只有它能够提出提案，这样就能保证算法的正常执行。<br>如果分布式系统能够正常运行，那么主proposer的方案使得系统的liveness（响应、活跃度）也能得到保证。  </p>\n<h2 id=\"2-算法扩展\"><a href=\"#2-算法扩展\" class=\"headerlink\" title=\"2 算法扩展\"></a>2 算法扩展</h2><p>基本的Paxos算法称为Basic Paxos，它允许多个proposer同时提出提案。本算法的一个变种是Mutility Paxos，它通过利用单个主proposer同时向多个Paxos实例发出prepare请求，在后续的决议过程中直接跳过prepare阶段，直接执行accept阶段，提高算法的运行效率。之所以可以跳过prepare阶段，是因为采用了单一proposer，且只有该proposer负责提出议案，议案编号也由它生成，可以保证不存在prepare阶段中可能存在的冲突，不再需要通过prepare阶段来检测冲突。</p>\n"},{"title":"Beautiful Words","date":"2017-04-03T02:02:20.000Z","_content":"\n1. I am not a smart man, but I know what love is. - 阿甘\n2. Life was like a box of chocolates, you never know what you’re gonna get.\n3. 永远不要试图用战术上的勤奋，去掩饰战略上的懒惰。\n4. I will keep waiting until I do not care about her.\n5. 人生不应该是充满痛苦疲惫的拉锯战，而应该是有的放矢地走走停停。\n6. 你为什么要努力？因为我不想把这个世界，让给我所鄙视的人。\n7. 普林斯顿 2012 毕业演讲：不要吞吃命运的饼干。生活的结果，虽不是完全随机的，却掺杂了很多运气成分在其中。如果你获得成功，你同时就获得好运，而运气带来义务。你欠了一笔债，不只是欠你的神，你也欠那些没你那么好运的人的债。\n8. 生命中，有些错过，最后成为了错过，而有些错过，因为两个人的勇敢，又变成了相遇。\n9. 我们都期待美满的故事，但其实恰恰是靠着我们的勇气，让故事变得美满，如果你不够勇敢，你很快就会出局。\n10. 有哪些比[我爱你]更戳心的表白？\n\t- 余生请指教。\n\t- 我去了你的城，走过你走的路，吃你爱吃的东西，我顺着你的经历，完成我缺席的记忆。\n11. 最怕一生碌碌无为，还说平凡难能可贵。\n12. 不在一起就不在一起吧，反正一辈子也没多长。\n13. 十年前你说生如夏花般绚烂，十年后你说平凡才是唯一的答案\n14. 祝你们幸福是假的，祝你幸福是真的\n15. 我想做一个能在你的葬礼上，描述你一生的人\n16. 你那么孤独，却说一个人真好\n\n\n\n","source":"_posts/Words.md","raw":"---\ntitle: Beautiful Words\ndate: 2017-04-03 10:02:20\ntags:\n---\n\n1. I am not a smart man, but I know what love is. - 阿甘\n2. Life was like a box of chocolates, you never know what you’re gonna get.\n3. 永远不要试图用战术上的勤奋，去掩饰战略上的懒惰。\n4. I will keep waiting until I do not care about her.\n5. 人生不应该是充满痛苦疲惫的拉锯战，而应该是有的放矢地走走停停。\n6. 你为什么要努力？因为我不想把这个世界，让给我所鄙视的人。\n7. 普林斯顿 2012 毕业演讲：不要吞吃命运的饼干。生活的结果，虽不是完全随机的，却掺杂了很多运气成分在其中。如果你获得成功，你同时就获得好运，而运气带来义务。你欠了一笔债，不只是欠你的神，你也欠那些没你那么好运的人的债。\n8. 生命中，有些错过，最后成为了错过，而有些错过，因为两个人的勇敢，又变成了相遇。\n9. 我们都期待美满的故事，但其实恰恰是靠着我们的勇气，让故事变得美满，如果你不够勇敢，你很快就会出局。\n10. 有哪些比[我爱你]更戳心的表白？\n\t- 余生请指教。\n\t- 我去了你的城，走过你走的路，吃你爱吃的东西，我顺着你的经历，完成我缺席的记忆。\n11. 最怕一生碌碌无为，还说平凡难能可贵。\n12. 不在一起就不在一起吧，反正一辈子也没多长。\n13. 十年前你说生如夏花般绚烂，十年后你说平凡才是唯一的答案\n14. 祝你们幸福是假的，祝你幸福是真的\n15. 我想做一个能在你的葬礼上，描述你一生的人\n16. 你那么孤独，却说一个人真好\n\n\n\n","slug":"Words","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahk0007pvs65qsmppt3","content":"<ol>\n<li>I am not a smart man, but I know what love is. - 阿甘</li>\n<li>Life was like a box of chocolates, you never know what you’re gonna get.</li>\n<li>永远不要试图用战术上的勤奋，去掩饰战略上的懒惰。</li>\n<li>I will keep waiting until I do not care about her.</li>\n<li>人生不应该是充满痛苦疲惫的拉锯战，而应该是有的放矢地走走停停。</li>\n<li>你为什么要努力？因为我不想把这个世界，让给我所鄙视的人。</li>\n<li>普林斯顿 2012 毕业演讲：不要吞吃命运的饼干。生活的结果，虽不是完全随机的，却掺杂了很多运气成分在其中。如果你获得成功，你同时就获得好运，而运气带来义务。你欠了一笔债，不只是欠你的神，你也欠那些没你那么好运的人的债。</li>\n<li>生命中，有些错过，最后成为了错过，而有些错过，因为两个人的勇敢，又变成了相遇。</li>\n<li>我们都期待美满的故事，但其实恰恰是靠着我们的勇气，让故事变得美满，如果你不够勇敢，你很快就会出局。</li>\n<li>有哪些比[我爱你]更戳心的表白？<ul>\n<li>余生请指教。</li>\n<li>我去了你的城，走过你走的路，吃你爱吃的东西，我顺着你的经历，完成我缺席的记忆。</li>\n</ul>\n</li>\n<li>最怕一生碌碌无为，还说平凡难能可贵。</li>\n<li>不在一起就不在一起吧，反正一辈子也没多长。</li>\n<li>十年前你说生如夏花般绚烂，十年后你说平凡才是唯一的答案</li>\n<li>祝你们幸福是假的，祝你幸福是真的</li>\n<li>我想做一个能在你的葬礼上，描述你一生的人</li>\n<li>你那么孤独，却说一个人真好</li>\n</ol>\n","excerpt":"","more":"<ol>\n<li>I am not a smart man, but I know what love is. - 阿甘</li>\n<li>Life was like a box of chocolates, you never know what you’re gonna get.</li>\n<li>永远不要试图用战术上的勤奋，去掩饰战略上的懒惰。</li>\n<li>I will keep waiting until I do not care about her.</li>\n<li>人生不应该是充满痛苦疲惫的拉锯战，而应该是有的放矢地走走停停。</li>\n<li>你为什么要努力？因为我不想把这个世界，让给我所鄙视的人。</li>\n<li>普林斯顿 2012 毕业演讲：不要吞吃命运的饼干。生活的结果，虽不是完全随机的，却掺杂了很多运气成分在其中。如果你获得成功，你同时就获得好运，而运气带来义务。你欠了一笔债，不只是欠你的神，你也欠那些没你那么好运的人的债。</li>\n<li>生命中，有些错过，最后成为了错过，而有些错过，因为两个人的勇敢，又变成了相遇。</li>\n<li>我们都期待美满的故事，但其实恰恰是靠着我们的勇气，让故事变得美满，如果你不够勇敢，你很快就会出局。</li>\n<li>有哪些比[我爱你]更戳心的表白？<ul>\n<li>余生请指教。</li>\n<li>我去了你的城，走过你走的路，吃你爱吃的东西，我顺着你的经历，完成我缺席的记忆。</li>\n</ul>\n</li>\n<li>最怕一生碌碌无为，还说平凡难能可贵。</li>\n<li>不在一起就不在一起吧，反正一辈子也没多长。</li>\n<li>十年前你说生如夏花般绚烂，十年后你说平凡才是唯一的答案</li>\n<li>祝你们幸福是假的，祝你幸福是真的</li>\n<li>我想做一个能在你的葬礼上，描述你一生的人</li>\n<li>你那么孤独，却说一个人真好</li>\n</ol>\n"},{"title":"Sublime Text 2 快捷键总结","date":"2017-04-03T07:16:35.000Z","_content":"### Mac OS\n\n1. ctrl + shift + down/up：光标多选\n2. ctrl + super + down/up：移动行\n3. shift + super + d：复制当前行为新行\n4. \n5. \n\n### Windows\n1. Ctrl+G：快速跳转到某一行\n2. Ctrl+Shift+d：复制当前行并插入到下面\n3. Ctrl+m：光标跳转到当前括号的匹配处\n","source":"_posts/Sublime-Text-2-快捷键总结.md","raw":"---\ntitle: Sublime Text 2 快捷键总结\ndate: 2017-04-03 15:16:35\ntags: [sublime text, 快捷键]\n---\n### Mac OS\n\n1. ctrl + shift + down/up：光标多选\n2. ctrl + super + down/up：移动行\n3. shift + super + d：复制当前行为新行\n4. \n5. \n\n### Windows\n1. Ctrl+G：快速跳转到某一行\n2. Ctrl+Shift+d：复制当前行并插入到下面\n3. Ctrl+m：光标跳转到当前括号的匹配处\n","slug":"Sublime-Text-2-快捷键总结","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahl0008pvs6a9odbjjm","content":"<h3 id=\"Mac-OS\"><a href=\"#Mac-OS\" class=\"headerlink\" title=\"Mac OS\"></a>Mac OS</h3><ol>\n<li>ctrl + shift + down/up：光标多选</li>\n<li>ctrl + super + down/up：移动行</li>\n<li>shift + super + d：复制当前行为新行</li>\n<li></li>\n<li></li>\n</ol>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ol>\n<li>Ctrl+G：快速跳转到某一行</li>\n<li>Ctrl+Shift+d：复制当前行并插入到下面</li>\n<li>Ctrl+m：光标跳转到当前括号的匹配处</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"Mac-OS\"><a href=\"#Mac-OS\" class=\"headerlink\" title=\"Mac OS\"></a>Mac OS</h3><ol>\n<li>ctrl + shift + down/up：光标多选</li>\n<li>ctrl + super + down/up：移动行</li>\n<li>shift + super + d：复制当前行为新行</li>\n<li></li>\n<li></li>\n</ol>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ol>\n<li>Ctrl+G：快速跳转到某一行</li>\n<li>Ctrl+Shift+d：复制当前行并插入到下面</li>\n<li>Ctrl+m：光标跳转到当前括号的匹配处</li>\n</ol>\n"},{"title":"如何使用hexo","date":"2017-04-03T01:45:54.000Z","_content":"\n配置过程参考如下博客：\n- [ibruce](http://ibruce.info/2013/11/22/hexo-your-blog/)  \n- jacman主题[配置](http://wuchong.me/jacman/how-to-use-jacman/)\n\n## 问题解决\n如果npm install -g hexo 失败，尝试使用淘宝的[镜像网站](http://npm.taobao.org/)，或者去hexo[官网](http://hexo.io/)。\n\n### Quick Start\nCreate a new post  \n\n\t$ hexo new \"My New Post\"\n\nRun server\n\n\t$ hexo server\n\nClean files\n\n\t$ hexo clean\n\nGenerate static files\n\n\t$ hexo generate\n\nDeploy to remote sites\n\n\t$ hexo deploy\n\n上述各个命令均可以使用缩写模式，即仅写出参数的第一个字母：\n\t$ hexo s/c/g/d\n","source":"_posts/如何使用hexo.md","raw":"---\ntitle: 如何使用hexo\ndate: 2017-04-03 09:45:54\ntags: hexo\n---\n\n配置过程参考如下博客：\n- [ibruce](http://ibruce.info/2013/11/22/hexo-your-blog/)  \n- jacman主题[配置](http://wuchong.me/jacman/how-to-use-jacman/)\n\n## 问题解决\n如果npm install -g hexo 失败，尝试使用淘宝的[镜像网站](http://npm.taobao.org/)，或者去hexo[官网](http://hexo.io/)。\n\n### Quick Start\nCreate a new post  \n\n\t$ hexo new \"My New Post\"\n\nRun server\n\n\t$ hexo server\n\nClean files\n\n\t$ hexo clean\n\nGenerate static files\n\n\t$ hexo generate\n\nDeploy to remote sites\n\n\t$ hexo deploy\n\n上述各个命令均可以使用缩写模式，即仅写出参数的第一个字母：\n\t$ hexo s/c/g/d\n","slug":"如何使用hexo","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahm0009pvs6aofz4k72","content":"<p>配置过程参考如下博客：</p>\n<ul>\n<li><a href=\"http://ibruce.info/2013/11/22/hexo-your-blog/\" target=\"_blank\" rel=\"external\">ibruce</a>  </li>\n<li>jacman主题<a href=\"http://wuchong.me/jacman/how-to-use-jacman/\" target=\"_blank\" rel=\"external\">配置</a></li>\n</ul>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><p>如果npm install -g hexo 失败，尝试使用淘宝的<a href=\"http://npm.taobao.org/\" target=\"_blank\" rel=\"external\">镜像网站</a>，或者去hexo<a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">官网</a>。</p>\n<h3 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h3><p>Create a new post  </p>\n<pre><code>$ hexo new &quot;My New Post&quot;\n</code></pre><p>Run server</p>\n<pre><code>$ hexo server\n</code></pre><p>Clean files</p>\n<pre><code>$ hexo clean\n</code></pre><p>Generate static files</p>\n<pre><code>$ hexo generate\n</code></pre><p>Deploy to remote sites</p>\n<pre><code>$ hexo deploy\n</code></pre><p>上述各个命令均可以使用缩写模式，即仅写出参数的第一个字母：<br>    $ hexo s/c/g/d</p>\n","excerpt":"","more":"<p>配置过程参考如下博客：</p>\n<ul>\n<li><a href=\"http://ibruce.info/2013/11/22/hexo-your-blog/\">ibruce</a>  </li>\n<li>jacman主题<a href=\"http://wuchong.me/jacman/how-to-use-jacman/\">配置</a></li>\n</ul>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><p>如果npm install -g hexo 失败，尝试使用淘宝的<a href=\"http://npm.taobao.org/\">镜像网站</a>，或者去hexo<a href=\"http://hexo.io/\">官网</a>。</p>\n<h3 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h3><p>Create a new post  </p>\n<pre><code>$ hexo new &quot;My New Post&quot;\n</code></pre><p>Run server</p>\n<pre><code>$ hexo server\n</code></pre><p>Clean files</p>\n<pre><code>$ hexo clean\n</code></pre><p>Generate static files</p>\n<pre><code>$ hexo generate\n</code></pre><p>Deploy to remote sites</p>\n<pre><code>$ hexo deploy\n</code></pre><p>上述各个命令均可以使用缩写模式，即仅写出参数的第一个字母：<br>    $ hexo s/c/g/d</p>\n"},{"title":"头文件中定义函数引发的multiple definition","date":"2017-04-03T08:08:14.000Z","_content":"\n> 本文引用了[博文](https://zybuluo.com/uuprince/note/81709)，感谢原文作者。\n\n**问题**：某个头文件中声明并定义了一个函数，然后在多个源码文件中调用该函数，编译链接时出现了该函数multiple definition问题，在头文件中添加了 #ifndef 头也不行，经过尝试发现如果将该函数的声明和定义分开到.h和.cpp文件之后问题消失，为什么不能将函数直接定义在.h文件中呢？\n\n\n针对该问题，抽象出如下几个问题：  \n\n### 1. 头文件中只可以放置函数声明，不可以放置函数定义吗？\n以下面的程序为例：   \n```c++\n// a.h\n#ifndef __a_h__\n#define __a_h__\nvoid funcA(void);   // 声明\nvoid funcA(void)    // 定义\n{}\n#endif\n\n// b.h\n#ifndef __b_h__\n#define __b_h__\nvoid funcB(void);\n#endif\n\n// b.cpp\n#include \"b.h\"\n#include \"a.h\"\nvoid funcB(void)\n{\n    funcA();\n}\n\n//c.h\n#ifndef __c_h__\n#define __c_h__\nvoid funcC(void);\n#endif\n\n//c.cpp\n#include \"c.h\"\n#include \"a.h\"\nvoid funcC(void)\n{\n    funcA();\n}\n\n//main.cpp\n#include \"b.h\"\n#include \"c.h\"\nint main(int argc, char* argv[])\n{\n    funcB();\n    funcC();\n    return 0;\n}\n```\n\n上述代码编译链接的时候编译器（g++）会报如下错误：  \n```\nc.o: In function `funcA()':\nc.cpp:(.text+0x0): multiple definition of `funcA()'\nb.o:b.cpp:(.text+0x0): first defined here\ncollect2: ld returned 1 exit status\n```\n\n> 为什么编译器在链接的时候会抱怨“funcA()重复定义”？\n> 其实本质问题就是funcA的定义被放在了a.h中，如果写在a.cpp中，就不会有重复定义的问题。下面分析一下编译过程都发生了什么，这样更容易从编译器的角度理解此问题。\n\n编译器处理include指令很简单粗暴，就是直接把头文件中的内容包含进来。所以b.cpp、c.cpp和main.cpp代码展开后可以简化为：  \n\n```c++\n// b.cpp\nvoid funcA(void);   // 声明\nvoid funcA(void)    // 定义\n{}\nvoid funcB(void);\nvoid funcB(void)\n{\n    funcA();\n}\n\n// c.cpp\nvoid funcA(void);   // 声明\nvoid funcA(void)    // 定义\n{}\nvoid funcC(void);\nvoid funcC(void)\n{\n    funcA();\n}\n\n// main.cpp\nvoid funcB(void);\nvoid funcC(void);\nint main(int argc, char* argv[])\n{\n    funcB();\n    funcC();\n    return 0;\n}\n```\n编译的时候，C++是采用独立编译，就是每个cpp单独编译成对应的.o文件，最后链接器再将多个.o文件链接成可执行程序。所以从编译的时候，从各个cpp文件看，编译没有任何问题。但是能发现一个问题，b.o中声明和定义了一次funcA()，c.o中也声明和定义funcA()，这就是编译器报重复定义的原因。有人可能会问，既然是从同一份文件include过来的函数funcA，那么定义都是同一份，为什么编译器不会智能的处理一下，让链接时候不报错呢？  \n其实编译器链接的时候，并不知道b.cpp中定义的funcA与c.cpp中定义的funcA是同一个文件include过来的，它只会认为如果有两份定义，而且这两份定义如果实现不同，那么到底以哪个为准呢？既然决定不了，那就干脆报错好了。  \n\n### 2. 为什么有些头文件中直接把函数定义都写进去了？\n刚才的分析，可以得出结论：头文件中只做变量和函数的声明，而不要定义，否则就会有重复定义的错误。但是有几种情况是例外的。  \n\n* 内联函数的定义\n* 类（class）的定义\n* const 和 static 变量\n\n以上几种可以在头文件中定义，下面逐个进行解释。  \n内联的目的就是在编译期让编译器把使用函数的地方直接替换掉，而不是像普通函数一样通过链接器把地址链接上。这种情况，如果定义没有在头文件的话，编译器是无法进行函数替换的。所以C++规定，内联函数可以在程序中定义多次，只要内联函数定义在同一个cpp中只出现一次就行。  \n按照这个理论，上述a.h简单修改一下就可以避免重复定义了。  \n\n```c++\n// a.h\n#ifndef __a_h__\n#define __a_h__\ninline void funcA(void);   // 内联声明\nvoid funcA(void)    // 定义\n{}\n#endif\n```\n此外，类（class）的定义，可以放在头文件中。  \n用类创建对象的时候，编译器要知道对象如何布局才能分配内存，因此类的定义需要在头文件中。一般情况下，我们把类内成员函数的定义放在cpp文件中，但是如果直接在class中完成函数声明+定义的话，这种函数会被编译器当作inline的，因此满足上面inline函数可以放在头文件的规则。但是如果声明和定义分开实现，但是都放在头文件中，那就会报重复定义了！！  \nconst 和 static 变量，可以放在头文件中。  \nconst对象默认是static的，而不是extern的，所以即使放在头文件中声明和定义。多个cpp引用同一个头文件，互相也没有感知，所以不会导致重复定义。  \n\n### 3. 模板函数/类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？\n\n前面分析可知，头文件中要么只有函数声明，要么是含有inline函数的定义。但是模板的定义(包括非inline函数/成员函数)要求声明和实现都必须放在头文件中，难道没有“重复定义”的问题？？？  \n答案当然是不会有问题（要不template早就被抱怨死了）。其实编译器也考虑到会遇到类似的问题，在编译器或连接器的某处已经有防止重定义的处理了。这里参考stackflow中的答案：http://stackoverflow.com/questions/235616/multiple-definitions-of-a-function-template\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/头文件中定义函数引发的multiple-definition.md","raw":"---\ntitle: 头文件中定义函数引发的multiple definition\ndate: 2017-04-03 16:08:14\ntags: C++\n---\n\n> 本文引用了[博文](https://zybuluo.com/uuprince/note/81709)，感谢原文作者。\n\n**问题**：某个头文件中声明并定义了一个函数，然后在多个源码文件中调用该函数，编译链接时出现了该函数multiple definition问题，在头文件中添加了 #ifndef 头也不行，经过尝试发现如果将该函数的声明和定义分开到.h和.cpp文件之后问题消失，为什么不能将函数直接定义在.h文件中呢？\n\n\n针对该问题，抽象出如下几个问题：  \n\n### 1. 头文件中只可以放置函数声明，不可以放置函数定义吗？\n以下面的程序为例：   \n```c++\n// a.h\n#ifndef __a_h__\n#define __a_h__\nvoid funcA(void);   // 声明\nvoid funcA(void)    // 定义\n{}\n#endif\n\n// b.h\n#ifndef __b_h__\n#define __b_h__\nvoid funcB(void);\n#endif\n\n// b.cpp\n#include \"b.h\"\n#include \"a.h\"\nvoid funcB(void)\n{\n    funcA();\n}\n\n//c.h\n#ifndef __c_h__\n#define __c_h__\nvoid funcC(void);\n#endif\n\n//c.cpp\n#include \"c.h\"\n#include \"a.h\"\nvoid funcC(void)\n{\n    funcA();\n}\n\n//main.cpp\n#include \"b.h\"\n#include \"c.h\"\nint main(int argc, char* argv[])\n{\n    funcB();\n    funcC();\n    return 0;\n}\n```\n\n上述代码编译链接的时候编译器（g++）会报如下错误：  \n```\nc.o: In function `funcA()':\nc.cpp:(.text+0x0): multiple definition of `funcA()'\nb.o:b.cpp:(.text+0x0): first defined here\ncollect2: ld returned 1 exit status\n```\n\n> 为什么编译器在链接的时候会抱怨“funcA()重复定义”？\n> 其实本质问题就是funcA的定义被放在了a.h中，如果写在a.cpp中，就不会有重复定义的问题。下面分析一下编译过程都发生了什么，这样更容易从编译器的角度理解此问题。\n\n编译器处理include指令很简单粗暴，就是直接把头文件中的内容包含进来。所以b.cpp、c.cpp和main.cpp代码展开后可以简化为：  \n\n```c++\n// b.cpp\nvoid funcA(void);   // 声明\nvoid funcA(void)    // 定义\n{}\nvoid funcB(void);\nvoid funcB(void)\n{\n    funcA();\n}\n\n// c.cpp\nvoid funcA(void);   // 声明\nvoid funcA(void)    // 定义\n{}\nvoid funcC(void);\nvoid funcC(void)\n{\n    funcA();\n}\n\n// main.cpp\nvoid funcB(void);\nvoid funcC(void);\nint main(int argc, char* argv[])\n{\n    funcB();\n    funcC();\n    return 0;\n}\n```\n编译的时候，C++是采用独立编译，就是每个cpp单独编译成对应的.o文件，最后链接器再将多个.o文件链接成可执行程序。所以从编译的时候，从各个cpp文件看，编译没有任何问题。但是能发现一个问题，b.o中声明和定义了一次funcA()，c.o中也声明和定义funcA()，这就是编译器报重复定义的原因。有人可能会问，既然是从同一份文件include过来的函数funcA，那么定义都是同一份，为什么编译器不会智能的处理一下，让链接时候不报错呢？  \n其实编译器链接的时候，并不知道b.cpp中定义的funcA与c.cpp中定义的funcA是同一个文件include过来的，它只会认为如果有两份定义，而且这两份定义如果实现不同，那么到底以哪个为准呢？既然决定不了，那就干脆报错好了。  \n\n### 2. 为什么有些头文件中直接把函数定义都写进去了？\n刚才的分析，可以得出结论：头文件中只做变量和函数的声明，而不要定义，否则就会有重复定义的错误。但是有几种情况是例外的。  \n\n* 内联函数的定义\n* 类（class）的定义\n* const 和 static 变量\n\n以上几种可以在头文件中定义，下面逐个进行解释。  \n内联的目的就是在编译期让编译器把使用函数的地方直接替换掉，而不是像普通函数一样通过链接器把地址链接上。这种情况，如果定义没有在头文件的话，编译器是无法进行函数替换的。所以C++规定，内联函数可以在程序中定义多次，只要内联函数定义在同一个cpp中只出现一次就行。  \n按照这个理论，上述a.h简单修改一下就可以避免重复定义了。  \n\n```c++\n// a.h\n#ifndef __a_h__\n#define __a_h__\ninline void funcA(void);   // 内联声明\nvoid funcA(void)    // 定义\n{}\n#endif\n```\n此外，类（class）的定义，可以放在头文件中。  \n用类创建对象的时候，编译器要知道对象如何布局才能分配内存，因此类的定义需要在头文件中。一般情况下，我们把类内成员函数的定义放在cpp文件中，但是如果直接在class中完成函数声明+定义的话，这种函数会被编译器当作inline的，因此满足上面inline函数可以放在头文件的规则。但是如果声明和定义分开实现，但是都放在头文件中，那就会报重复定义了！！  \nconst 和 static 变量，可以放在头文件中。  \nconst对象默认是static的，而不是extern的，所以即使放在头文件中声明和定义。多个cpp引用同一个头文件，互相也没有感知，所以不会导致重复定义。  \n\n### 3. 模板函数/类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？\n\n前面分析可知，头文件中要么只有函数声明，要么是含有inline函数的定义。但是模板的定义(包括非inline函数/成员函数)要求声明和实现都必须放在头文件中，难道没有“重复定义”的问题？？？  \n答案当然是不会有问题（要不template早就被抱怨死了）。其实编译器也考虑到会遇到类似的问题，在编译器或连接器的某处已经有防止重定义的处理了。这里参考stackflow中的答案：http://stackoverflow.com/questions/235616/multiple-definitions-of-a-function-template\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"头文件中定义函数引发的multiple-definition","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3aho000apvs6wy3rwwex","content":"<blockquote>\n<p>本文引用了<a href=\"https://zybuluo.com/uuprince/note/81709\" target=\"_blank\" rel=\"external\">博文</a>，感谢原文作者。</p>\n</blockquote>\n<p><strong>问题</strong>：某个头文件中声明并定义了一个函数，然后在多个源码文件中调用该函数，编译链接时出现了该函数multiple definition问题，在头文件中添加了 #ifndef 头也不行，经过尝试发现如果将该函数的声明和定义分开到.h和.cpp文件之后问题消失，为什么不能将函数直接定义在.h文件中呢？</p>\n<p>针对该问题，抽象出如下几个问题：  </p>\n<h3 id=\"1-头文件中只可以放置函数声明，不可以放置函数定义吗？\"><a href=\"#1-头文件中只可以放置函数声明，不可以放置函数定义吗？\" class=\"headerlink\" title=\"1. 头文件中只可以放置函数声明，不可以放置函数定义吗？\"></a>1. 头文件中只可以放置函数声明，不可以放置函数定义吗？</h3><p>以下面的程序为例：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// a.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __a_h__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __a_h__</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;   <span class=\"comment\">// 声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>    <span class=\"comment\">// 定义</span></span></div><div class=\"line\">&#123;&#125;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// b.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __b_h__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __b_h__</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// b.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    funcA();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//c.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __c_h__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __c_h__</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//c.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"c.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    funcA();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"c.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    funcB();</div><div class=\"line\">    funcC();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上述代码编译链接的时候编译器（g++）会报如下错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">c.o: In function `funcA()&apos;:</div><div class=\"line\">c.cpp:(.text+0x0): multiple definition of `funcA()&apos;</div><div class=\"line\">b.o:b.cpp:(.text+0x0): first defined here</div><div class=\"line\">collect2: ld returned 1 exit status</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>为什么编译器在链接的时候会抱怨“funcA()重复定义”？<br>其实本质问题就是funcA的定义被放在了a.h中，如果写在a.cpp中，就不会有重复定义的问题。下面分析一下编译过程都发生了什么，这样更容易从编译器的角度理解此问题。</p>\n</blockquote>\n<p>编译器处理include指令很简单粗暴，就是直接把头文件中的内容包含进来。所以b.cpp、c.cpp和main.cpp代码展开后可以简化为：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// b.cpp</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;   <span class=\"comment\">// 声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>    <span class=\"comment\">// 定义</span></span></div><div class=\"line\">&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    funcA();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// c.cpp</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;   <span class=\"comment\">// 声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>    <span class=\"comment\">// 定义</span></span></div><div class=\"line\">&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    funcA();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.cpp</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    funcB();</div><div class=\"line\">    funcC();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译的时候，C++是采用独立编译，就是每个cpp单独编译成对应的.o文件，最后链接器再将多个.o文件链接成可执行程序。所以从编译的时候，从各个cpp文件看，编译没有任何问题。但是能发现一个问题，b.o中声明和定义了一次funcA()，c.o中也声明和定义funcA()，这就是编译器报重复定义的原因。有人可能会问，既然是从同一份文件include过来的函数funcA，那么定义都是同一份，为什么编译器不会智能的处理一下，让链接时候不报错呢？<br>其实编译器链接的时候，并不知道b.cpp中定义的funcA与c.cpp中定义的funcA是同一个文件include过来的，它只会认为如果有两份定义，而且这两份定义如果实现不同，那么到底以哪个为准呢？既然决定不了，那就干脆报错好了。  </p>\n<h3 id=\"2-为什么有些头文件中直接把函数定义都写进去了？\"><a href=\"#2-为什么有些头文件中直接把函数定义都写进去了？\" class=\"headerlink\" title=\"2. 为什么有些头文件中直接把函数定义都写进去了？\"></a>2. 为什么有些头文件中直接把函数定义都写进去了？</h3><p>刚才的分析，可以得出结论：头文件中只做变量和函数的声明，而不要定义，否则就会有重复定义的错误。但是有几种情况是例外的。  </p>\n<ul>\n<li>内联函数的定义</li>\n<li>类（class）的定义</li>\n<li>const 和 static 变量</li>\n</ul>\n<p>以上几种可以在头文件中定义，下面逐个进行解释。<br>内联的目的就是在编译期让编译器把使用函数的地方直接替换掉，而不是像普通函数一样通过链接器把地址链接上。这种情况，如果定义没有在头文件的话，编译器是无法进行函数替换的。所以C++规定，内联函数可以在程序中定义多次，只要内联函数定义在同一个cpp中只出现一次就行。<br>按照这个理论，上述a.h简单修改一下就可以避免重复定义了。  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// a.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __a_h__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __a_h__</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;   <span class=\"comment\">// 内联声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>    <span class=\"comment\">// 定义</span></span></div><div class=\"line\">&#123;&#125;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure>\n<p>此外，类（class）的定义，可以放在头文件中。<br>用类创建对象的时候，编译器要知道对象如何布局才能分配内存，因此类的定义需要在头文件中。一般情况下，我们把类内成员函数的定义放在cpp文件中，但是如果直接在class中完成函数声明+定义的话，这种函数会被编译器当作inline的，因此满足上面inline函数可以放在头文件的规则。但是如果声明和定义分开实现，但是都放在头文件中，那就会报重复定义了！！<br>const 和 static 变量，可以放在头文件中。<br>const对象默认是static的，而不是extern的，所以即使放在头文件中声明和定义。多个cpp引用同一个头文件，互相也没有感知，所以不会导致重复定义。  </p>\n<h3 id=\"3-模板函数-类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？\"><a href=\"#3-模板函数-类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？\" class=\"headerlink\" title=\"3. 模板函数/类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？\"></a>3. 模板函数/类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？</h3><p>前面分析可知，头文件中要么只有函数声明，要么是含有inline函数的定义。但是模板的定义(包括非inline函数/成员函数)要求声明和实现都必须放在头文件中，难道没有“重复定义”的问题？？？<br>答案当然是不会有问题（要不template早就被抱怨死了）。其实编译器也考虑到会遇到类似的问题，在编译器或连接器的某处已经有防止重定义的处理了。这里参考stackflow中的答案：<a href=\"http://stackoverflow.com/questions/235616/multiple-definitions-of-a-function-template\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/235616/multiple-definitions-of-a-function-template</a></p>\n","excerpt":"","more":"<blockquote>\n<p>本文引用了<a href=\"https://zybuluo.com/uuprince/note/81709\">博文</a>，感谢原文作者。</p>\n</blockquote>\n<p><strong>问题</strong>：某个头文件中声明并定义了一个函数，然后在多个源码文件中调用该函数，编译链接时出现了该函数multiple definition问题，在头文件中添加了 #ifndef 头也不行，经过尝试发现如果将该函数的声明和定义分开到.h和.cpp文件之后问题消失，为什么不能将函数直接定义在.h文件中呢？</p>\n<p>针对该问题，抽象出如下几个问题：  </p>\n<h3 id=\"1-头文件中只可以放置函数声明，不可以放置函数定义吗？\"><a href=\"#1-头文件中只可以放置函数声明，不可以放置函数定义吗？\" class=\"headerlink\" title=\"1. 头文件中只可以放置函数声明，不可以放置函数定义吗？\"></a>1. 头文件中只可以放置函数声明，不可以放置函数定义吗？</h3><p>以下面的程序为例：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// a.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __a_h__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __a_h__</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;   <span class=\"comment\">// 声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>    <span class=\"comment\">// 定义</span></div><div class=\"line\"></span>&#123;&#125;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// b.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __b_h__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __b_h__</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// b.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    funcA();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//c.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __c_h__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __c_h__</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//c.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"c.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    funcA();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"c.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    funcB();</div><div class=\"line\">    funcC();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上述代码编译链接的时候编译器（g++）会报如下错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">c.o: In function `funcA()&apos;:</div><div class=\"line\">c.cpp:(.text+0x0): multiple definition of `funcA()&apos;</div><div class=\"line\">b.o:b.cpp:(.text+0x0): first defined here</div><div class=\"line\">collect2: ld returned 1 exit status</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>为什么编译器在链接的时候会抱怨“funcA()重复定义”？<br>其实本质问题就是funcA的定义被放在了a.h中，如果写在a.cpp中，就不会有重复定义的问题。下面分析一下编译过程都发生了什么，这样更容易从编译器的角度理解此问题。</p>\n</blockquote>\n<p>编译器处理include指令很简单粗暴，就是直接把头文件中的内容包含进来。所以b.cpp、c.cpp和main.cpp代码展开后可以简化为：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// b.cpp</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;   <span class=\"comment\">// 声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>    <span class=\"comment\">// 定义</span></div><div class=\"line\"></span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    funcA();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// c.cpp</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;   <span class=\"comment\">// 声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>    <span class=\"comment\">// 定义</span></div><div class=\"line\"></span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    funcA();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.cpp</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcB</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcC</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    funcB();</div><div class=\"line\">    funcC();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译的时候，C++是采用独立编译，就是每个cpp单独编译成对应的.o文件，最后链接器再将多个.o文件链接成可执行程序。所以从编译的时候，从各个cpp文件看，编译没有任何问题。但是能发现一个问题，b.o中声明和定义了一次funcA()，c.o中也声明和定义funcA()，这就是编译器报重复定义的原因。有人可能会问，既然是从同一份文件include过来的函数funcA，那么定义都是同一份，为什么编译器不会智能的处理一下，让链接时候不报错呢？<br>其实编译器链接的时候，并不知道b.cpp中定义的funcA与c.cpp中定义的funcA是同一个文件include过来的，它只会认为如果有两份定义，而且这两份定义如果实现不同，那么到底以哪个为准呢？既然决定不了，那就干脆报错好了。  </p>\n<h3 id=\"2-为什么有些头文件中直接把函数定义都写进去了？\"><a href=\"#2-为什么有些头文件中直接把函数定义都写进去了？\" class=\"headerlink\" title=\"2. 为什么有些头文件中直接把函数定义都写进去了？\"></a>2. 为什么有些头文件中直接把函数定义都写进去了？</h3><p>刚才的分析，可以得出结论：头文件中只做变量和函数的声明，而不要定义，否则就会有重复定义的错误。但是有几种情况是例外的。  </p>\n<ul>\n<li>内联函数的定义</li>\n<li>类（class）的定义</li>\n<li>const 和 static 变量</li>\n</ul>\n<p>以上几种可以在头文件中定义，下面逐个进行解释。<br>内联的目的就是在编译期让编译器把使用函数的地方直接替换掉，而不是像普通函数一样通过链接器把地址链接上。这种情况，如果定义没有在头文件的话，编译器是无法进行函数替换的。所以C++规定，内联函数可以在程序中定义多次，只要内联函数定义在同一个cpp中只出现一次就行。<br>按照这个理论，上述a.h简单修改一下就可以避免重复定义了。  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// a.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __a_h__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __a_h__</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;   <span class=\"comment\">// 内联声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funcA</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>    <span class=\"comment\">// 定义</span></div><div class=\"line\"></span>&#123;&#125;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure>\n<p>此外，类（class）的定义，可以放在头文件中。<br>用类创建对象的时候，编译器要知道对象如何布局才能分配内存，因此类的定义需要在头文件中。一般情况下，我们把类内成员函数的定义放在cpp文件中，但是如果直接在class中完成函数声明+定义的话，这种函数会被编译器当作inline的，因此满足上面inline函数可以放在头文件的规则。但是如果声明和定义分开实现，但是都放在头文件中，那就会报重复定义了！！<br>const 和 static 变量，可以放在头文件中。<br>const对象默认是static的，而不是extern的，所以即使放在头文件中声明和定义。多个cpp引用同一个头文件，互相也没有感知，所以不会导致重复定义。  </p>\n<h3 id=\"3-模板函数-类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？\"><a href=\"#3-模板函数-类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？\" class=\"headerlink\" title=\"3. 模板函数/类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？\"></a>3. 模板函数/类中要求头文件中必须包含定义才能进行模板实例化，这种定义放在头文件的情况会不会有问题？</h3><p>前面分析可知，头文件中要么只有函数声明，要么是含有inline函数的定义。但是模板的定义(包括非inline函数/成员函数)要求声明和实现都必须放在头文件中，难道没有“重复定义”的问题？？？<br>答案当然是不会有问题（要不template早就被抱怨死了）。其实编译器也考虑到会遇到类似的问题，在编译器或连接器的某处已经有防止重定义的处理了。这里参考stackflow中的答案：<a href=\"http://stackoverflow.com/questions/235616/multiple-definitions-of-a-function-template\">http://stackoverflow.com/questions/235616/multiple-definitions-of-a-function-template</a></p>\n"},{"title":"数据库事务隔离级别","date":"2017-04-03T08:39:35.000Z","_content":"\n参考资料：  \nhttp://dblab.xmu.edu.cn/post/1359/  \nhttp://www.cnblogs.com/lyhabc/articles/3219693.html  \n\n## 一、SQL标准隔离级别\nSQL92标准中对数据库事务隔离级别进行了分类：  \n- read uncommitted\n- read committed\n- repeatable read\n- serializable\n\nSQL92事务隔离级别的定义是基于悲观锁的思想，例如教科书上的三级封锁协议的定义；商用数据库的实现过程中，多采用基于乐观锁的MVCC技术；商用数据库对事务隔离级别的定义，跟SQL92的标准是有所差别的。\n\n### 1.1 read uncommitted\n读写操作互不阻塞，但读操作可能读到未提交的脏数据。  \n实现时无需加锁。\n\n### 1.2 read committed\n\n读写操作会相互阻塞，因为每个读操作都要读到已提交的最新数据，当事务1读取数据项x，而事务2修改了x且执行commit trans之前，事务1的查询语句执行会阻塞，等待事务2完成commit操作之后才能读取到。  \n这个现象是语句级的，即事务中可能有多条语句，每条读写语句都遵循上述规则，一条查询语句必须等待其他针对相同数据项的更新语句（若存在的话）的提交才能执行。  \n实现方式是，读数据前必须首先获得一个读操作锁，一旦数据读取之后该锁被立即释放。  \n–示例：\n> 在此示例中，我们用两个session分别开启事务，一个读事务将读取数据，然后另一事务修改此数据。执行完的读操作（即事务内的select语句）不阻塞由其他事务的更新操作，即执行完毕的读不会阻塞写。但是，在其他事务已经做了更新操作后，读操作会被阻塞住，直到更新操作事务提交为止。\n\n--------------\n\n–Session 1：  \nUSE [db_test]  \nGO  \nBEGIN TRAN  \n–查询1  \n–这个查询将返回4号员工有48小时休假时间：  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n---------------  \n\n–Session 2：  \nUSE [db_test]  \nGO  \nBEGIN TRAN  \n–修改1  \n–休假时间减去8  \n–修改不会被阻塞，因为会话1不会持有S锁不放  \nUPDATE [HumanResources].[Employee]  \nSET [VacationHours]=[VacationHours]-8  \nWHERE [EmployeeID]=4  \n–查询1  \n–现在休假时间只有40小时  \nSELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n----------------  \n–Session 1：  \n–重新运行查询语句，会被会话2阻塞  \n–查询2  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n----------------\n–Session 2：  \n–提交事务  \nCOMMIT TRAN  \nGO  \n\n------------------\n–Session 1：  \n–此时先前被阻塞的查询结束，返回会话2修改好的新数据：40  \n–查询3  \n–这里返回40，因为会话2已经提交了事务：  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–修改2  \n–将该员工的时间再次减8，这里会成功：  \nUPDATE [HumanResources].[Employee]  \nSET [SickLeaveHours]=[SickLeaveHours]-8  \nWHERE [EmployeeID]=4  \nSELECT [SickLeaveHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–回滚会话1的修改  \n–会话2的修改将不受影响，此时值恢复为40：  \nROLLBACK TRAN  \nGO  \n\nSELECT [SickLeaveHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4\n\n\n### 1.3 repeatable read\n一个事务中的前后两次读操作总是保证能够读到相同的值，这是与read committed不同的地方(行级锁且锁住读操作的间隔，而read committed不锁间隔)。  \n可重复读可以避免脏读、不可重复读现象，但可能会出现幻想读（幻象即之前没出现的数据像幽灵一样突然出现），这是因为该隔离级别可以锁住已有数据，但可能其他事务又插入了新的符合检索条件的数据。\n实现方式是，事务在请求读数据之前必须获得一个锁，并且保持该锁直到事务结束。  \n\n### 1.4 serializable\n最高隔离级别，事务的执行仿佛是串行化的，或并发的事务执行结果是完全可串行化的。\n实现方式是，每个事务都直接锁住整张表。\n\n## 二、其他隔离级别\n在商用数据库中比较常见的有快照隔离、游标稳定性隔离、读一致等。  \n基于多版本并发控制MVCC技术可以实现多种隔离级别，如快照隔离、以及mvcc-based read committed（基于多版本的已提交读隔离级别）。  \n在SQL标准的read committed隔离级别下，一个读操作会和一个写操作相互阻塞。有些关系型数据库（例如ORACLE）使用的是另一种处理方式，在任何一个修改之前，先对修改前的版本做一个复制，后续的一切读操作都会去读这个复制的版本，修改将创建一个新的版本。在这种处理方式下，读、写操作不会互相阻塞。使用这种行版本控制机制的好处，是程序的并发性比较高，但是缺点是用户读到的虽然不是一个脏数据，但是可能是个正在被修改马上就要过期的数据值。如果根据这个过期的值做数据修改，会产生逻辑错误。有些用户可能为了更高的并发性而不在乎这种缺点，为了满足这部分用户的需求，SQL2005也引入了这种机制，来实现类似的功能。所以选取行版本并发控制隔离级别也可以成为消除阻塞和死锁的一种手段。  \nSQL有两种基于行版本并发控制的隔离级别：\n- 已提交读隔离（read_committed_snapshot）\n- 快照隔离级别\n\n### MVCC-Based Read committed\n示例：  \n– 使用行版本控制的已提交读\n– 在此示例中，使用行版本控制的已提交读事务与其他事务并发运行。已提交读事务的行为与快照事务的行为\n– 有所不同。与快照事务相同的是，即使其他事务修改了数据，已提交读事务也将读取版本化的行。\n– 与快照事务不同的是，已提交读将执行下列操作：\n–（1）在其他事务提交数据更改之后，读取修改的数据\n–（2）能够更新由其他事务修改的数据，而快照事务不能\n– 在会话1上：\n\nUSE [db_test]  \nGO  \n–启用行版本控制的已提交读  \n–注意运行这句话的时候，不可以有其他连接同时使用[db_test]  \nALTER DATABASE [db_test] SET READ_COMMITTED_SNAPSHOT ON  \nGO  \n–设置使用已提交读隔离级别  \nSET TRANSACTION ISOLATION LEVEL READ COMMITTED  \nGO  \nBEGIN TRAN  \n–查询1  \n–这里将返回初始值48  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n--------------\n–在会话2上：  \nUSE [db_test]  \nGO  \nBEGIN TRAN  \n–修改1  \n–假期时间减8  \n–修改不会被会话1阻塞  \nUPDATE [HumanResources].[Employee]  \nSET [VacationHours]=[VacationHours]-8  \nWHERE [EmployeeID]=4  \n–查询1  \n–确认值已经被修改为40  \nSELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n-----------------\n–在会话1上：  \n–查询2  \n–再次运行查询语句  \n–还是返回48（修改前的值），因为会话2还没有提交  \n–会话1是从版本化的行读取数据  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n--------------\n–在会话2上：  \n–提交事务  \nCOMMIT TRAN  \nGO  \n\n-------------\n–在会话1上：  \n–查询3  \n–这里和范例B不同，会话1始终返回已提交的值  \n–这里返回40，因为会话2已经提交了事务  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–修改2  \n–这里会成功  \nUPDATE [HumanResources].[Employee]  \nSET [SickLeaveHours]=[SickLeaveHours]-8  \nWHERE [EmployeeID]=4  \n–可以回滚会话1的修改  \n–会话2的修改不会受影响  \nROLLBACK TRAN  \nGO  \n\n----------------\n\n\n### 快照隔离级别\n\n快照隔离示例：  \n– 快照隔离\n– 此示例中，在快照隔离下运行的事务将读取数据，然后由另一个事务修改此数据。快照事务\n– 不阻塞由其他事务执行的更新操作，他忽略数据的修改继续从版本化的行读取数据。也就是\n– 说，读取到的是数据修改前的版本。但是，当快照事务尝试修改已由其他事务修改的数据时，\n– 他将生成错误并终止\n\n---------------\n–在会话1上：\nUSE [db_test]  \nGO  \n\n-----------\n– 启用快照隔离\nALTER DATABASE [db_test] SET ALLOW_SNAPSHOT_ISOLATION ON  \nGO  \n–设置使用快照隔离级别\nSET TRANSACTION ISOLATION LEVEL SNAPSHOT\nGO\nBEGIN TRAN\n–查询1\n–查询返回员工有48小时假期\nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4\n\n------------\n–在会话2上：  \nUSE [db_test]  \nGO  \nBEGIN TRAN  \n–修改1  \n–假期时间减8  \n–修改不会被会话1阻塞  \nUPDATE [HumanResources].[Employee]  \nSET [VacationHours]=[VacationHours]-8  \nWHERE [EmployeeID]=4  \n–查询1  \n–确认值已经被改成40  \nSELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–在会话1上：  \n–查询2  \n–再次运行查询语句  \n–还是返回48（修改前的值），因为会话1是从版本化的行读取数据  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–在会话2上：  \n–提交事务  \nCOMMIT TRAN  \nGO  \n\n-------------\n–在会话1上：  \n–查询3  \n–再次运行查询语句  \n–还是返回48（修改前的值），因为会话1还是从版本化的行读取数据  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–修改2  \n–因为数据已经被会话2修改过，会话1想做任何修改时  \n–会遇到3960错误  \n–事务会自动回滚  \nUPDATE [HumanResources].[Employee]  \nSET [SickLeaveHours]=[SickLeaveHours]-8  \nWHERE [EmployeeID]=4  \n–会话1的修改会回滚  \n–会话2的修改不会回滚  \nROLLBACK TRAN  \nGO  \n\n\n\n","source":"_posts/数据库事务隔离级别.md","raw":"---\ntitle: 数据库事务隔离级别\ndate: 2017-04-03 16:39:35\ntags: 隔离级别\n---\n\n参考资料：  \nhttp://dblab.xmu.edu.cn/post/1359/  \nhttp://www.cnblogs.com/lyhabc/articles/3219693.html  \n\n## 一、SQL标准隔离级别\nSQL92标准中对数据库事务隔离级别进行了分类：  \n- read uncommitted\n- read committed\n- repeatable read\n- serializable\n\nSQL92事务隔离级别的定义是基于悲观锁的思想，例如教科书上的三级封锁协议的定义；商用数据库的实现过程中，多采用基于乐观锁的MVCC技术；商用数据库对事务隔离级别的定义，跟SQL92的标准是有所差别的。\n\n### 1.1 read uncommitted\n读写操作互不阻塞，但读操作可能读到未提交的脏数据。  \n实现时无需加锁。\n\n### 1.2 read committed\n\n读写操作会相互阻塞，因为每个读操作都要读到已提交的最新数据，当事务1读取数据项x，而事务2修改了x且执行commit trans之前，事务1的查询语句执行会阻塞，等待事务2完成commit操作之后才能读取到。  \n这个现象是语句级的，即事务中可能有多条语句，每条读写语句都遵循上述规则，一条查询语句必须等待其他针对相同数据项的更新语句（若存在的话）的提交才能执行。  \n实现方式是，读数据前必须首先获得一个读操作锁，一旦数据读取之后该锁被立即释放。  \n–示例：\n> 在此示例中，我们用两个session分别开启事务，一个读事务将读取数据，然后另一事务修改此数据。执行完的读操作（即事务内的select语句）不阻塞由其他事务的更新操作，即执行完毕的读不会阻塞写。但是，在其他事务已经做了更新操作后，读操作会被阻塞住，直到更新操作事务提交为止。\n\n--------------\n\n–Session 1：  \nUSE [db_test]  \nGO  \nBEGIN TRAN  \n–查询1  \n–这个查询将返回4号员工有48小时休假时间：  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n---------------  \n\n–Session 2：  \nUSE [db_test]  \nGO  \nBEGIN TRAN  \n–修改1  \n–休假时间减去8  \n–修改不会被阻塞，因为会话1不会持有S锁不放  \nUPDATE [HumanResources].[Employee]  \nSET [VacationHours]=[VacationHours]-8  \nWHERE [EmployeeID]=4  \n–查询1  \n–现在休假时间只有40小时  \nSELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n----------------  \n–Session 1：  \n–重新运行查询语句，会被会话2阻塞  \n–查询2  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n----------------\n–Session 2：  \n–提交事务  \nCOMMIT TRAN  \nGO  \n\n------------------\n–Session 1：  \n–此时先前被阻塞的查询结束，返回会话2修改好的新数据：40  \n–查询3  \n–这里返回40，因为会话2已经提交了事务：  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–修改2  \n–将该员工的时间再次减8，这里会成功：  \nUPDATE [HumanResources].[Employee]  \nSET [SickLeaveHours]=[SickLeaveHours]-8  \nWHERE [EmployeeID]=4  \nSELECT [SickLeaveHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–回滚会话1的修改  \n–会话2的修改将不受影响，此时值恢复为40：  \nROLLBACK TRAN  \nGO  \n\nSELECT [SickLeaveHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4\n\n\n### 1.3 repeatable read\n一个事务中的前后两次读操作总是保证能够读到相同的值，这是与read committed不同的地方(行级锁且锁住读操作的间隔，而read committed不锁间隔)。  \n可重复读可以避免脏读、不可重复读现象，但可能会出现幻想读（幻象即之前没出现的数据像幽灵一样突然出现），这是因为该隔离级别可以锁住已有数据，但可能其他事务又插入了新的符合检索条件的数据。\n实现方式是，事务在请求读数据之前必须获得一个锁，并且保持该锁直到事务结束。  \n\n### 1.4 serializable\n最高隔离级别，事务的执行仿佛是串行化的，或并发的事务执行结果是完全可串行化的。\n实现方式是，每个事务都直接锁住整张表。\n\n## 二、其他隔离级别\n在商用数据库中比较常见的有快照隔离、游标稳定性隔离、读一致等。  \n基于多版本并发控制MVCC技术可以实现多种隔离级别，如快照隔离、以及mvcc-based read committed（基于多版本的已提交读隔离级别）。  \n在SQL标准的read committed隔离级别下，一个读操作会和一个写操作相互阻塞。有些关系型数据库（例如ORACLE）使用的是另一种处理方式，在任何一个修改之前，先对修改前的版本做一个复制，后续的一切读操作都会去读这个复制的版本，修改将创建一个新的版本。在这种处理方式下，读、写操作不会互相阻塞。使用这种行版本控制机制的好处，是程序的并发性比较高，但是缺点是用户读到的虽然不是一个脏数据，但是可能是个正在被修改马上就要过期的数据值。如果根据这个过期的值做数据修改，会产生逻辑错误。有些用户可能为了更高的并发性而不在乎这种缺点，为了满足这部分用户的需求，SQL2005也引入了这种机制，来实现类似的功能。所以选取行版本并发控制隔离级别也可以成为消除阻塞和死锁的一种手段。  \nSQL有两种基于行版本并发控制的隔离级别：\n- 已提交读隔离（read_committed_snapshot）\n- 快照隔离级别\n\n### MVCC-Based Read committed\n示例：  \n– 使用行版本控制的已提交读\n– 在此示例中，使用行版本控制的已提交读事务与其他事务并发运行。已提交读事务的行为与快照事务的行为\n– 有所不同。与快照事务相同的是，即使其他事务修改了数据，已提交读事务也将读取版本化的行。\n– 与快照事务不同的是，已提交读将执行下列操作：\n–（1）在其他事务提交数据更改之后，读取修改的数据\n–（2）能够更新由其他事务修改的数据，而快照事务不能\n– 在会话1上：\n\nUSE [db_test]  \nGO  \n–启用行版本控制的已提交读  \n–注意运行这句话的时候，不可以有其他连接同时使用[db_test]  \nALTER DATABASE [db_test] SET READ_COMMITTED_SNAPSHOT ON  \nGO  \n–设置使用已提交读隔离级别  \nSET TRANSACTION ISOLATION LEVEL READ COMMITTED  \nGO  \nBEGIN TRAN  \n–查询1  \n–这里将返回初始值48  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n--------------\n–在会话2上：  \nUSE [db_test]  \nGO  \nBEGIN TRAN  \n–修改1  \n–假期时间减8  \n–修改不会被会话1阻塞  \nUPDATE [HumanResources].[Employee]  \nSET [VacationHours]=[VacationHours]-8  \nWHERE [EmployeeID]=4  \n–查询1  \n–确认值已经被修改为40  \nSELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n-----------------\n–在会话1上：  \n–查询2  \n–再次运行查询语句  \n–还是返回48（修改前的值），因为会话2还没有提交  \n–会话1是从版本化的行读取数据  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n\n--------------\n–在会话2上：  \n–提交事务  \nCOMMIT TRAN  \nGO  \n\n-------------\n–在会话1上：  \n–查询3  \n–这里和范例B不同，会话1始终返回已提交的值  \n–这里返回40，因为会话2已经提交了事务  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–修改2  \n–这里会成功  \nUPDATE [HumanResources].[Employee]  \nSET [SickLeaveHours]=[SickLeaveHours]-8  \nWHERE [EmployeeID]=4  \n–可以回滚会话1的修改  \n–会话2的修改不会受影响  \nROLLBACK TRAN  \nGO  \n\n----------------\n\n\n### 快照隔离级别\n\n快照隔离示例：  \n– 快照隔离\n– 此示例中，在快照隔离下运行的事务将读取数据，然后由另一个事务修改此数据。快照事务\n– 不阻塞由其他事务执行的更新操作，他忽略数据的修改继续从版本化的行读取数据。也就是\n– 说，读取到的是数据修改前的版本。但是，当快照事务尝试修改已由其他事务修改的数据时，\n– 他将生成错误并终止\n\n---------------\n–在会话1上：\nUSE [db_test]  \nGO  \n\n-----------\n– 启用快照隔离\nALTER DATABASE [db_test] SET ALLOW_SNAPSHOT_ISOLATION ON  \nGO  \n–设置使用快照隔离级别\nSET TRANSACTION ISOLATION LEVEL SNAPSHOT\nGO\nBEGIN TRAN\n–查询1\n–查询返回员工有48小时假期\nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4\n\n------------\n–在会话2上：  \nUSE [db_test]  \nGO  \nBEGIN TRAN  \n–修改1  \n–假期时间减8  \n–修改不会被会话1阻塞  \nUPDATE [HumanResources].[Employee]  \nSET [VacationHours]=[VacationHours]-8  \nWHERE [EmployeeID]=4  \n–查询1  \n–确认值已经被改成40  \nSELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–在会话1上：  \n–查询2  \n–再次运行查询语句  \n–还是返回48（修改前的值），因为会话1是从版本化的行读取数据  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–在会话2上：  \n–提交事务  \nCOMMIT TRAN  \nGO  \n\n-------------\n–在会话1上：  \n–查询3  \n–再次运行查询语句  \n–还是返回48（修改前的值），因为会话1还是从版本化的行读取数据  \nSELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  \n–修改2  \n–因为数据已经被会话2修改过，会话1想做任何修改时  \n–会遇到3960错误  \n–事务会自动回滚  \nUPDATE [HumanResources].[Employee]  \nSET [SickLeaveHours]=[SickLeaveHours]-8  \nWHERE [EmployeeID]=4  \n–会话1的修改会回滚  \n–会话2的修改不会回滚  \nROLLBACK TRAN  \nGO  \n\n\n\n","slug":"数据库事务隔离级别","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahq000bpvs67t3ahjmu","content":"<p>参考资料：<br><a href=\"http://dblab.xmu.edu.cn/post/1359/\" target=\"_blank\" rel=\"external\">http://dblab.xmu.edu.cn/post/1359/</a><br><a href=\"http://www.cnblogs.com/lyhabc/articles/3219693.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/lyhabc/articles/3219693.html</a>  </p>\n<h2 id=\"一、SQL标准隔离级别\"><a href=\"#一、SQL标准隔离级别\" class=\"headerlink\" title=\"一、SQL标准隔离级别\"></a>一、SQL标准隔离级别</h2><p>SQL92标准中对数据库事务隔离级别进行了分类：  </p>\n<ul>\n<li>read uncommitted</li>\n<li>read committed</li>\n<li>repeatable read</li>\n<li>serializable</li>\n</ul>\n<p>SQL92事务隔离级别的定义是基于悲观锁的思想，例如教科书上的三级封锁协议的定义；商用数据库的实现过程中，多采用基于乐观锁的MVCC技术；商用数据库对事务隔离级别的定义，跟SQL92的标准是有所差别的。</p>\n<h3 id=\"1-1-read-uncommitted\"><a href=\"#1-1-read-uncommitted\" class=\"headerlink\" title=\"1.1 read uncommitted\"></a>1.1 read uncommitted</h3><p>读写操作互不阻塞，但读操作可能读到未提交的脏数据。<br>实现时无需加锁。</p>\n<h3 id=\"1-2-read-committed\"><a href=\"#1-2-read-committed\" class=\"headerlink\" title=\"1.2 read committed\"></a>1.2 read committed</h3><p>读写操作会相互阻塞，因为每个读操作都要读到已提交的最新数据，当事务1读取数据项x，而事务2修改了x且执行commit trans之前，事务1的查询语句执行会阻塞，等待事务2完成commit操作之后才能读取到。<br>这个现象是语句级的，即事务中可能有多条语句，每条读写语句都遵循上述规则，一条查询语句必须等待其他针对相同数据项的更新语句（若存在的话）的提交才能执行。<br>实现方式是，读数据前必须首先获得一个读操作锁，一旦数据读取之后该锁被立即释放。<br>–示例：</p>\n<blockquote>\n<p>在此示例中，我们用两个session分别开启事务，一个读事务将读取数据，然后另一事务修改此数据。执行完的读操作（即事务内的select语句）不阻塞由其他事务的更新操作，即执行完毕的读不会阻塞写。但是，在其他事务已经做了更新操作后，读操作会被阻塞住，直到更新操作事务提交为止。</p>\n</blockquote>\n<hr>\n<p>–Session 1：<br>USE [db_test]<br>GO<br>BEGIN TRAN<br>–查询1<br>–这个查询将返回4号员工有48小时休假时间：<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–Session 2：<br>USE [db_test]<br>GO<br>BEGIN TRAN<br>–修改1<br>–休假时间减去8<br>–修改不会被阻塞，因为会话1不会持有S锁不放<br>UPDATE [HumanResources].[Employee]<br>SET [VacationHours]=[VacationHours]-8<br>WHERE [EmployeeID]=4<br>–查询1<br>–现在休假时间只有40小时<br>SELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–Session 1：<br>–重新运行查询语句，会被会话2阻塞<br>–查询2<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–Session 2：<br>–提交事务<br>COMMIT TRAN<br>GO  </p>\n<hr>\n<p>–Session 1：<br>–此时先前被阻塞的查询结束，返回会话2修改好的新数据：40<br>–查询3<br>–这里返回40，因为会话2已经提交了事务：<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–修改2<br>–将该员工的时间再次减8，这里会成功：<br>UPDATE [HumanResources].[Employee]<br>SET [SickLeaveHours]=[SickLeaveHours]-8<br>WHERE [EmployeeID]=4<br>SELECT [SickLeaveHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–回滚会话1的修改<br>–会话2的修改将不受影响，此时值恢复为40：<br>ROLLBACK TRAN<br>GO  </p>\n<p>SELECT [SickLeaveHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4</p>\n<h3 id=\"1-3-repeatable-read\"><a href=\"#1-3-repeatable-read\" class=\"headerlink\" title=\"1.3 repeatable read\"></a>1.3 repeatable read</h3><p>一个事务中的前后两次读操作总是保证能够读到相同的值，这是与read committed不同的地方(行级锁且锁住读操作的间隔，而read committed不锁间隔)。<br>可重复读可以避免脏读、不可重复读现象，但可能会出现幻想读（幻象即之前没出现的数据像幽灵一样突然出现），这是因为该隔离级别可以锁住已有数据，但可能其他事务又插入了新的符合检索条件的数据。<br>实现方式是，事务在请求读数据之前必须获得一个锁，并且保持该锁直到事务结束。  </p>\n<h3 id=\"1-4-serializable\"><a href=\"#1-4-serializable\" class=\"headerlink\" title=\"1.4 serializable\"></a>1.4 serializable</h3><p>最高隔离级别，事务的执行仿佛是串行化的，或并发的事务执行结果是完全可串行化的。<br>实现方式是，每个事务都直接锁住整张表。</p>\n<h2 id=\"二、其他隔离级别\"><a href=\"#二、其他隔离级别\" class=\"headerlink\" title=\"二、其他隔离级别\"></a>二、其他隔离级别</h2><p>在商用数据库中比较常见的有快照隔离、游标稳定性隔离、读一致等。<br>基于多版本并发控制MVCC技术可以实现多种隔离级别，如快照隔离、以及mvcc-based read committed（基于多版本的已提交读隔离级别）。<br>在SQL标准的read committed隔离级别下，一个读操作会和一个写操作相互阻塞。有些关系型数据库（例如ORACLE）使用的是另一种处理方式，在任何一个修改之前，先对修改前的版本做一个复制，后续的一切读操作都会去读这个复制的版本，修改将创建一个新的版本。在这种处理方式下，读、写操作不会互相阻塞。使用这种行版本控制机制的好处，是程序的并发性比较高，但是缺点是用户读到的虽然不是一个脏数据，但是可能是个正在被修改马上就要过期的数据值。如果根据这个过期的值做数据修改，会产生逻辑错误。有些用户可能为了更高的并发性而不在乎这种缺点，为了满足这部分用户的需求，SQL2005也引入了这种机制，来实现类似的功能。所以选取行版本并发控制隔离级别也可以成为消除阻塞和死锁的一种手段。<br>SQL有两种基于行版本并发控制的隔离级别：</p>\n<ul>\n<li>已提交读隔离（read_committed_snapshot）</li>\n<li>快照隔离级别</li>\n</ul>\n<h3 id=\"MVCC-Based-Read-committed\"><a href=\"#MVCC-Based-Read-committed\" class=\"headerlink\" title=\"MVCC-Based Read committed\"></a>MVCC-Based Read committed</h3><p>示例：<br>– 使用行版本控制的已提交读<br>– 在此示例中，使用行版本控制的已提交读事务与其他事务并发运行。已提交读事务的行为与快照事务的行为<br>– 有所不同。与快照事务相同的是，即使其他事务修改了数据，已提交读事务也将读取版本化的行。<br>– 与快照事务不同的是，已提交读将执行下列操作：<br>–（1）在其他事务提交数据更改之后，读取修改的数据<br>–（2）能够更新由其他事务修改的数据，而快照事务不能<br>– 在会话1上：</p>\n<p>USE [db_test]<br>GO<br>–启用行版本控制的已提交读<br>–注意运行这句话的时候，不可以有其他连接同时使用[db_test]<br>ALTER DATABASE [db_test] SET READ_COMMITTED_SNAPSHOT ON<br>GO<br>–设置使用已提交读隔离级别<br>SET TRANSACTION ISOLATION LEVEL READ COMMITTED<br>GO<br>BEGIN TRAN<br>–查询1<br>–这里将返回初始值48<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–在会话2上：<br>USE [db_test]<br>GO<br>BEGIN TRAN<br>–修改1<br>–假期时间减8<br>–修改不会被会话1阻塞<br>UPDATE [HumanResources].[Employee]<br>SET [VacationHours]=[VacationHours]-8<br>WHERE [EmployeeID]=4<br>–查询1<br>–确认值已经被修改为40<br>SELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–在会话1上：<br>–查询2<br>–再次运行查询语句<br>–还是返回48（修改前的值），因为会话2还没有提交<br>–会话1是从版本化的行读取数据<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–在会话2上：<br>–提交事务<br>COMMIT TRAN<br>GO  </p>\n<hr>\n<p>–在会话1上：<br>–查询3<br>–这里和范例B不同，会话1始终返回已提交的值<br>–这里返回40，因为会话2已经提交了事务<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–修改2<br>–这里会成功<br>UPDATE [HumanResources].[Employee]<br>SET [SickLeaveHours]=[SickLeaveHours]-8<br>WHERE [EmployeeID]=4<br>–可以回滚会话1的修改<br>–会话2的修改不会受影响<br>ROLLBACK TRAN<br>GO  </p>\n<hr>\n<h3 id=\"快照隔离级别\"><a href=\"#快照隔离级别\" class=\"headerlink\" title=\"快照隔离级别\"></a>快照隔离级别</h3><p>快照隔离示例：<br>– 快照隔离<br>– 此示例中，在快照隔离下运行的事务将读取数据，然后由另一个事务修改此数据。快照事务<br>– 不阻塞由其他事务执行的更新操作，他忽略数据的修改继续从版本化的行读取数据。也就是<br>– 说，读取到的是数据修改前的版本。但是，当快照事务尝试修改已由其他事务修改的数据时，<br>– 他将生成错误并终止</p>\n<hr>\n<p>–在会话1上：<br>USE [db_test]<br>GO  </p>\n<hr>\n<p>– 启用快照隔离<br>ALTER DATABASE [db_test] SET ALLOW_SNAPSHOT_ISOLATION ON<br>GO<br>–设置使用快照隔离级别<br>SET TRANSACTION ISOLATION LEVEL SNAPSHOT<br>GO<br>BEGIN TRAN<br>–查询1<br>–查询返回员工有48小时假期<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4</p>\n<hr>\n<p>–在会话2上：<br>USE [db_test]<br>GO<br>BEGIN TRAN<br>–修改1<br>–假期时间减8<br>–修改不会被会话1阻塞<br>UPDATE [HumanResources].[Employee]<br>SET [VacationHours]=[VacationHours]-8<br>WHERE [EmployeeID]=4<br>–查询1<br>–确认值已经被改成40<br>SELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–在会话1上：<br>–查询2<br>–再次运行查询语句<br>–还是返回48（修改前的值），因为会话1是从版本化的行读取数据<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–在会话2上：<br>–提交事务<br>COMMIT TRAN<br>GO  </p>\n<hr>\n<p>–在会话1上：<br>–查询3<br>–再次运行查询语句<br>–还是返回48（修改前的值），因为会话1还是从版本化的行读取数据<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–修改2<br>–因为数据已经被会话2修改过，会话1想做任何修改时<br>–会遇到3960错误<br>–事务会自动回滚<br>UPDATE [HumanResources].[Employee]<br>SET [SickLeaveHours]=[SickLeaveHours]-8<br>WHERE [EmployeeID]=4<br>–会话1的修改会回滚<br>–会话2的修改不会回滚<br>ROLLBACK TRAN<br>GO  </p>\n","excerpt":"","more":"<p>参考资料：<br><a href=\"http://dblab.xmu.edu.cn/post/1359/\">http://dblab.xmu.edu.cn/post/1359/</a><br><a href=\"http://www.cnblogs.com/lyhabc/articles/3219693.html\">http://www.cnblogs.com/lyhabc/articles/3219693.html</a>  </p>\n<h2 id=\"一、SQL标准隔离级别\"><a href=\"#一、SQL标准隔离级别\" class=\"headerlink\" title=\"一、SQL标准隔离级别\"></a>一、SQL标准隔离级别</h2><p>SQL92标准中对数据库事务隔离级别进行了分类：  </p>\n<ul>\n<li>read uncommitted</li>\n<li>read committed</li>\n<li>repeatable read</li>\n<li>serializable</li>\n</ul>\n<p>SQL92事务隔离级别的定义是基于悲观锁的思想，例如教科书上的三级封锁协议的定义；商用数据库的实现过程中，多采用基于乐观锁的MVCC技术；商用数据库对事务隔离级别的定义，跟SQL92的标准是有所差别的。</p>\n<h3 id=\"1-1-read-uncommitted\"><a href=\"#1-1-read-uncommitted\" class=\"headerlink\" title=\"1.1 read uncommitted\"></a>1.1 read uncommitted</h3><p>读写操作互不阻塞，但读操作可能读到未提交的脏数据。<br>实现时无需加锁。</p>\n<h3 id=\"1-2-read-committed\"><a href=\"#1-2-read-committed\" class=\"headerlink\" title=\"1.2 read committed\"></a>1.2 read committed</h3><p>读写操作会相互阻塞，因为每个读操作都要读到已提交的最新数据，当事务1读取数据项x，而事务2修改了x且执行commit trans之前，事务1的查询语句执行会阻塞，等待事务2完成commit操作之后才能读取到。<br>这个现象是语句级的，即事务中可能有多条语句，每条读写语句都遵循上述规则，一条查询语句必须等待其他针对相同数据项的更新语句（若存在的话）的提交才能执行。<br>实现方式是，读数据前必须首先获得一个读操作锁，一旦数据读取之后该锁被立即释放。<br>–示例：</p>\n<blockquote>\n<p>在此示例中，我们用两个session分别开启事务，一个读事务将读取数据，然后另一事务修改此数据。执行完的读操作（即事务内的select语句）不阻塞由其他事务的更新操作，即执行完毕的读不会阻塞写。但是，在其他事务已经做了更新操作后，读操作会被阻塞住，直到更新操作事务提交为止。</p>\n</blockquote>\n<hr>\n<p>–Session 1：<br>USE [db_test]<br>GO<br>BEGIN TRAN<br>–查询1<br>–这个查询将返回4号员工有48小时休假时间：<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–Session 2：<br>USE [db_test]<br>GO<br>BEGIN TRAN<br>–修改1<br>–休假时间减去8<br>–修改不会被阻塞，因为会话1不会持有S锁不放<br>UPDATE [HumanResources].[Employee]<br>SET [VacationHours]=[VacationHours]-8<br>WHERE [EmployeeID]=4<br>–查询1<br>–现在休假时间只有40小时<br>SELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–Session 1：<br>–重新运行查询语句，会被会话2阻塞<br>–查询2<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–Session 2：<br>–提交事务<br>COMMIT TRAN<br>GO  </p>\n<hr>\n<p>–Session 1：<br>–此时先前被阻塞的查询结束，返回会话2修改好的新数据：40<br>–查询3<br>–这里返回40，因为会话2已经提交了事务：<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–修改2<br>–将该员工的时间再次减8，这里会成功：<br>UPDATE [HumanResources].[Employee]<br>SET [SickLeaveHours]=[SickLeaveHours]-8<br>WHERE [EmployeeID]=4<br>SELECT [SickLeaveHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–回滚会话1的修改<br>–会话2的修改将不受影响，此时值恢复为40：<br>ROLLBACK TRAN<br>GO  </p>\n<p>SELECT [SickLeaveHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4</p>\n<h3 id=\"1-3-repeatable-read\"><a href=\"#1-3-repeatable-read\" class=\"headerlink\" title=\"1.3 repeatable read\"></a>1.3 repeatable read</h3><p>一个事务中的前后两次读操作总是保证能够读到相同的值，这是与read committed不同的地方(行级锁且锁住读操作的间隔，而read committed不锁间隔)。<br>可重复读可以避免脏读、不可重复读现象，但可能会出现幻想读（幻象即之前没出现的数据像幽灵一样突然出现），这是因为该隔离级别可以锁住已有数据，但可能其他事务又插入了新的符合检索条件的数据。<br>实现方式是，事务在请求读数据之前必须获得一个锁，并且保持该锁直到事务结束。  </p>\n<h3 id=\"1-4-serializable\"><a href=\"#1-4-serializable\" class=\"headerlink\" title=\"1.4 serializable\"></a>1.4 serializable</h3><p>最高隔离级别，事务的执行仿佛是串行化的，或并发的事务执行结果是完全可串行化的。<br>实现方式是，每个事务都直接锁住整张表。</p>\n<h2 id=\"二、其他隔离级别\"><a href=\"#二、其他隔离级别\" class=\"headerlink\" title=\"二、其他隔离级别\"></a>二、其他隔离级别</h2><p>在商用数据库中比较常见的有快照隔离、游标稳定性隔离、读一致等。<br>基于多版本并发控制MVCC技术可以实现多种隔离级别，如快照隔离、以及mvcc-based read committed（基于多版本的已提交读隔离级别）。<br>在SQL标准的read committed隔离级别下，一个读操作会和一个写操作相互阻塞。有些关系型数据库（例如ORACLE）使用的是另一种处理方式，在任何一个修改之前，先对修改前的版本做一个复制，后续的一切读操作都会去读这个复制的版本，修改将创建一个新的版本。在这种处理方式下，读、写操作不会互相阻塞。使用这种行版本控制机制的好处，是程序的并发性比较高，但是缺点是用户读到的虽然不是一个脏数据，但是可能是个正在被修改马上就要过期的数据值。如果根据这个过期的值做数据修改，会产生逻辑错误。有些用户可能为了更高的并发性而不在乎这种缺点，为了满足这部分用户的需求，SQL2005也引入了这种机制，来实现类似的功能。所以选取行版本并发控制隔离级别也可以成为消除阻塞和死锁的一种手段。<br>SQL有两种基于行版本并发控制的隔离级别：</p>\n<ul>\n<li>已提交读隔离（read_committed_snapshot）</li>\n<li>快照隔离级别</li>\n</ul>\n<h3 id=\"MVCC-Based-Read-committed\"><a href=\"#MVCC-Based-Read-committed\" class=\"headerlink\" title=\"MVCC-Based Read committed\"></a>MVCC-Based Read committed</h3><p>示例：<br>– 使用行版本控制的已提交读<br>– 在此示例中，使用行版本控制的已提交读事务与其他事务并发运行。已提交读事务的行为与快照事务的行为<br>– 有所不同。与快照事务相同的是，即使其他事务修改了数据，已提交读事务也将读取版本化的行。<br>– 与快照事务不同的是，已提交读将执行下列操作：<br>–（1）在其他事务提交数据更改之后，读取修改的数据<br>–（2）能够更新由其他事务修改的数据，而快照事务不能<br>– 在会话1上：</p>\n<p>USE [db_test]<br>GO<br>–启用行版本控制的已提交读<br>–注意运行这句话的时候，不可以有其他连接同时使用[db_test]<br>ALTER DATABASE [db_test] SET READ_COMMITTED_SNAPSHOT ON<br>GO<br>–设置使用已提交读隔离级别<br>SET TRANSACTION ISOLATION LEVEL READ COMMITTED<br>GO<br>BEGIN TRAN<br>–查询1<br>–这里将返回初始值48<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–在会话2上：<br>USE [db_test]<br>GO<br>BEGIN TRAN<br>–修改1<br>–假期时间减8<br>–修改不会被会话1阻塞<br>UPDATE [HumanResources].[Employee]<br>SET [VacationHours]=[VacationHours]-8<br>WHERE [EmployeeID]=4<br>–查询1<br>–确认值已经被修改为40<br>SELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–在会话1上：<br>–查询2<br>–再次运行查询语句<br>–还是返回48（修改前的值），因为会话2还没有提交<br>–会话1是从版本化的行读取数据<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4  </p>\n<hr>\n<p>–在会话2上：<br>–提交事务<br>COMMIT TRAN<br>GO  </p>\n<hr>\n<p>–在会话1上：<br>–查询3<br>–这里和范例B不同，会话1始终返回已提交的值<br>–这里返回40，因为会话2已经提交了事务<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–修改2<br>–这里会成功<br>UPDATE [HumanResources].[Employee]<br>SET [SickLeaveHours]=[SickLeaveHours]-8<br>WHERE [EmployeeID]=4<br>–可以回滚会话1的修改<br>–会话2的修改不会受影响<br>ROLLBACK TRAN<br>GO  </p>\n<hr>\n<h3 id=\"快照隔离级别\"><a href=\"#快照隔离级别\" class=\"headerlink\" title=\"快照隔离级别\"></a>快照隔离级别</h3><p>快照隔离示例：<br>– 快照隔离<br>– 此示例中，在快照隔离下运行的事务将读取数据，然后由另一个事务修改此数据。快照事务<br>– 不阻塞由其他事务执行的更新操作，他忽略数据的修改继续从版本化的行读取数据。也就是<br>– 说，读取到的是数据修改前的版本。但是，当快照事务尝试修改已由其他事务修改的数据时，<br>– 他将生成错误并终止</p>\n<hr>\n<p>–在会话1上：<br>USE [db_test]<br>GO  </p>\n<hr>\n<p>– 启用快照隔离<br>ALTER DATABASE [db_test] SET ALLOW_SNAPSHOT_ISOLATION ON<br>GO<br>–设置使用快照隔离级别<br>SET TRANSACTION ISOLATION LEVEL SNAPSHOT<br>GO<br>BEGIN TRAN<br>–查询1<br>–查询返回员工有48小时假期<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4</p>\n<hr>\n<p>–在会话2上：<br>USE [db_test]<br>GO<br>BEGIN TRAN<br>–修改1<br>–假期时间减8<br>–修改不会被会话1阻塞<br>UPDATE [HumanResources].[Employee]<br>SET [VacationHours]=[VacationHours]-8<br>WHERE [EmployeeID]=4<br>–查询1<br>–确认值已经被改成40<br>SELECT [VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–在会话1上：<br>–查询2<br>–再次运行查询语句<br>–还是返回48（修改前的值），因为会话1是从版本化的行读取数据<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–在会话2上：<br>–提交事务<br>COMMIT TRAN<br>GO  </p>\n<hr>\n<p>–在会话1上：<br>–查询3<br>–再次运行查询语句<br>–还是返回48（修改前的值），因为会话1还是从版本化的行读取数据<br>SELECT [EmployeeID],[VacationHours] FROM [HumanResources].[Employee] WHERE [EmployeeID]=4<br>–修改2<br>–因为数据已经被会话2修改过，会话1想做任何修改时<br>–会遇到3960错误<br>–事务会自动回滚<br>UPDATE [HumanResources].[Employee]<br>SET [SickLeaveHours]=[SickLeaveHours]-8<br>WHERE [EmployeeID]=4<br>–会话1的修改会回滚<br>–会话2的修改不会回滚<br>ROLLBACK TRAN<br>GO  </p>\n"},{"title":"time - Linux下统计程序运行时间","date":"2017-04-03T01:45:54.000Z","_content":"\n\nLinux下编程时，当我们需要统计一个程序的执行时间，可以使用系统的time程序。根据这篇[文章](http://soft.chinabyte.com/os/22/11698522.shtml)的描述，time命令获取一个程序的执行时间包括程序的实际运行时间(real time)，以及程序运行在用户态的时间(user time)和内核态的时间(sys time)。\n下面是一段示例代码，向文件中写入几行数字：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <unistd.h>     //可以不加\n\nusing namespace std;\n\nint main(){\n    FILE *fp = fopen(\"tmp.out\", \"r\");\n    int i=0, x;\n    for(i=0; i<5; i++){\n        fprintf(fp, \"%d\\n\", i);\n    }\n    fclose(fp);\n\n    return 0;\n}\n```\n\n运行：  \n```\n$g++ test.cc  \n$time ./a.out\n```\n\n结果：\n```\nreal    0m0.020s\nuser    0m0.001s\nsys     0m0.003s\n```\n\n可以看出，该程序实际运行时间为0.02秒，用户态运行时间0.001s，内核态运行时间为0.003s。内核态运行时间较长是因为使用了文件相关的系统调用，主要工作是在写文件。你可能发现，real并不是user和sys的总和，这是因为real代表的是程序从开始到结束的全部时间，即使程序不占CPU也统计时间。而user+sys是程序占用CPU的总时间，因此real总是大于或者等于user+sys的。下面我们用sleep来验证一下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <unistd.h>     //可以不加\n\nusing namespace std;\n\nint main(){\n    FILE *fp = fopen(\"tmp.out\", \"r\");\n    int i=0, x;\n    for(i=0; i<5; i++){\n        sleep(1);\n        fscanf(fp, \"%d\\n\", &x);\n        cout<<\"x = \"<< x << endl;\n    }\n    fclose(fp);\n\n    return 0;\n}\n```\n运行结果：\n\n```\nx = 0\nx = 1\nx = 2\nx = 3\nx = 4\n\nreal    0m5.007s\nuser    0m0.001s\nsys     0m0.004s\n```\n可以看出，睡眠时，程序并不占用user和sys的时间。\nOver.\n\n\n","source":"_posts/time-linux程序运行时间统计.md","raw":"---\ntitle: time - Linux下统计程序运行时间\ndate: 2017-04-03 09:45:54\ntags: time\n---\n\n\nLinux下编程时，当我们需要统计一个程序的执行时间，可以使用系统的time程序。根据这篇[文章](http://soft.chinabyte.com/os/22/11698522.shtml)的描述，time命令获取一个程序的执行时间包括程序的实际运行时间(real time)，以及程序运行在用户态的时间(user time)和内核态的时间(sys time)。\n下面是一段示例代码，向文件中写入几行数字：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <unistd.h>     //可以不加\n\nusing namespace std;\n\nint main(){\n    FILE *fp = fopen(\"tmp.out\", \"r\");\n    int i=0, x;\n    for(i=0; i<5; i++){\n        fprintf(fp, \"%d\\n\", i);\n    }\n    fclose(fp);\n\n    return 0;\n}\n```\n\n运行：  \n```\n$g++ test.cc  \n$time ./a.out\n```\n\n结果：\n```\nreal    0m0.020s\nuser    0m0.001s\nsys     0m0.003s\n```\n\n可以看出，该程序实际运行时间为0.02秒，用户态运行时间0.001s，内核态运行时间为0.003s。内核态运行时间较长是因为使用了文件相关的系统调用，主要工作是在写文件。你可能发现，real并不是user和sys的总和，这是因为real代表的是程序从开始到结束的全部时间，即使程序不占CPU也统计时间。而user+sys是程序占用CPU的总时间，因此real总是大于或者等于user+sys的。下面我们用sleep来验证一下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <unistd.h>     //可以不加\n\nusing namespace std;\n\nint main(){\n    FILE *fp = fopen(\"tmp.out\", \"r\");\n    int i=0, x;\n    for(i=0; i<5; i++){\n        sleep(1);\n        fscanf(fp, \"%d\\n\", &x);\n        cout<<\"x = \"<< x << endl;\n    }\n    fclose(fp);\n\n    return 0;\n}\n```\n运行结果：\n\n```\nx = 0\nx = 1\nx = 2\nx = 3\nx = 4\n\nreal    0m5.007s\nuser    0m0.001s\nsys     0m0.004s\n```\n可以看出，睡眠时，程序并不占用user和sys的时间。\nOver.\n\n\n","slug":"time-linux程序运行时间统计","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahr000cpvs6mbuomf1u","content":"<p>Linux下编程时，当我们需要统计一个程序的执行时间，可以使用系统的time程序。根据这篇<a href=\"http://soft.chinabyte.com/os/22/11698522.shtml\" target=\"_blank\" rel=\"external\">文章</a>的描述，time命令获取一个程序的执行时间包括程序的实际运行时间(real time)，以及程序运行在用户态的时间(user time)和内核态的时间(sys time)。<br>下面是一段示例代码，向文件中写入几行数字：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;     //可以不加</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    FILE *fp = fopen(<span class=\"string\">\"tmp.out\"</span>, <span class=\"string\">\"r\"</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, x;</div><div class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++)&#123;</div><div class=\"line\">        <span class=\"built_in\">fprintf</span>(fp, <span class=\"string\">\"%d\\n\"</span>, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    fclose(fp);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$g++ test.cc  </div><div class=\"line\">$time ./a.out</div></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">real    0m0.020s</div><div class=\"line\">user    0m0.001s</div><div class=\"line\">sys     0m0.003s</div></pre></td></tr></table></figure></p>\n<p>可以看出，该程序实际运行时间为0.02秒，用户态运行时间0.001s，内核态运行时间为0.003s。内核态运行时间较长是因为使用了文件相关的系统调用，主要工作是在写文件。你可能发现，real并不是user和sys的总和，这是因为real代表的是程序从开始到结束的全部时间，即使程序不占CPU也统计时间。而user+sys是程序占用CPU的总时间，因此real总是大于或者等于user+sys的。下面我们用sleep来验证一下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;     //可以不加</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    FILE *fp = fopen(<span class=\"string\">\"tmp.out\"</span>, <span class=\"string\">\"r\"</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, x;</div><div class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++)&#123;</div><div class=\"line\">        sleep(<span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"built_in\">fscanf</span>(fp, <span class=\"string\">\"%d\\n\"</span>, &amp;x);</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"x = \"</span>&lt;&lt; x &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    fclose(fp);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = 0</div><div class=\"line\">x = 1</div><div class=\"line\">x = 2</div><div class=\"line\">x = 3</div><div class=\"line\">x = 4</div><div class=\"line\"></div><div class=\"line\">real    0m5.007s</div><div class=\"line\">user    0m0.001s</div><div class=\"line\">sys     0m0.004s</div></pre></td></tr></table></figure>\n<p>可以看出，睡眠时，程序并不占用user和sys的时间。<br>Over.</p>\n","excerpt":"","more":"<p>Linux下编程时，当我们需要统计一个程序的执行时间，可以使用系统的time程序。根据这篇<a href=\"http://soft.chinabyte.com/os/22/11698522.shtml\">文章</a>的描述，time命令获取一个程序的执行时间包括程序的实际运行时间(real time)，以及程序运行在用户态的时间(user time)和内核态的时间(sys time)。<br>下面是一段示例代码，向文件中写入几行数字：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;     //可以不加</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    FILE *fp = fopen(<span class=\"string\">\"tmp.out\"</span>, <span class=\"string\">\"r\"</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, x;</div><div class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++)&#123;</div><div class=\"line\">        <span class=\"built_in\">fprintf</span>(fp, <span class=\"string\">\"%d\\n\"</span>, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    fclose(fp);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$g++ test.cc  </div><div class=\"line\">$time ./a.out</div></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">real    0m0.020s</div><div class=\"line\">user    0m0.001s</div><div class=\"line\">sys     0m0.003s</div></pre></td></tr></table></figure></p>\n<p>可以看出，该程序实际运行时间为0.02秒，用户态运行时间0.001s，内核态运行时间为0.003s。内核态运行时间较长是因为使用了文件相关的系统调用，主要工作是在写文件。你可能发现，real并不是user和sys的总和，这是因为real代表的是程序从开始到结束的全部时间，即使程序不占CPU也统计时间。而user+sys是程序占用CPU的总时间，因此real总是大于或者等于user+sys的。下面我们用sleep来验证一下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;     //可以不加</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    FILE *fp = fopen(<span class=\"string\">\"tmp.out\"</span>, <span class=\"string\">\"r\"</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, x;</div><div class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++)&#123;</div><div class=\"line\">        sleep(<span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"built_in\">fscanf</span>(fp, <span class=\"string\">\"%d\\n\"</span>, &amp;x);</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"x = \"</span>&lt;&lt; x &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    fclose(fp);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = 0</div><div class=\"line\">x = 1</div><div class=\"line\">x = 2</div><div class=\"line\">x = 3</div><div class=\"line\">x = 4</div><div class=\"line\"></div><div class=\"line\">real    0m5.007s</div><div class=\"line\">user    0m0.001s</div><div class=\"line\">sys     0m0.004s</div></pre></td></tr></table></figure>\n<p>可以看出，睡眠时，程序并不占用user和sys的时间。<br>Over.</p>\n"},{"title":"自旋锁SpinLock","date":"2017-04-03T08:34:11.000Z","_content":"\n## 常见的锁机制\nPosix Threads（Pthreads）是在多核平台中进行多线程并行编程常用的API。它也提供了多种锁机制来实现多个线程对临界区的互斥访问，锁机制是实现线程同步的一种手段，另外一种手段是barrier机制，可以实现内存区域的同步。  \nPthreads库提供乐如下几种锁：  \n\n* mutex（互斥量）\n* Spin lock（自旋锁）\n* conditional variable（条件变量）\n* read/write lock（读写锁）\n\n### 1.1 mutex\nmutex属于sleep-waiting类型的锁，也就是说，当线程1想要锁住mutex进入临界区，那么如果mutex当前被其他线程持有，线程1就会进入阻塞状态（blocking），CPU核心会进行上下文切换将该线程放入等待队列，并开始运行其他线程。  \nPthread提供的mutex操作API如下：  \n```\npthread_mutex_lock (pthread_mutex_t *mutex);\npthread_mutex_trylock (pthread_mutex_t *mutex);\npthread_mutex_unlock (pthread_mutex_t *mutex);\n```\n\n### 1.2 spin lock\n自旋锁是一种busy-waiting类型的锁，也就是说，当线程2想要获取某个自旋锁时，如果当前该锁被其他线程持有，那么线程2不会阻塞，而是一直在当前CPU核心上进行忙等待并不断询问该锁是否被释放，直到获取为止。  \n由于自旋锁是忙等待，不会引起调用者被切换，这样一旦锁变为可用状态，可以立刻获取到，因此自旋锁的效率要比普通的互斥锁高。但它也有一些不足之处：  \n* 自旋锁等待过程中会一直占用CPU，这样如果短时间内不能获取到锁，那么CPU就在空转，使得CPU利用率降低。\n* 使用过程中也可能出现死锁。\n因此，自旋锁的适用场景是：锁的使用者持有锁的时间比较短，很快就会释放。否则，不适合使用自旋锁。  \nPthread提供的spin lock操作API如下：  \n```\npthread_spin_lock (pthread_spinlock_t *lock);\npthread_spin_trylock (pthread_spinlock_t *lock);\npthread_spin_unlock (pthread_spinlock_t *lock);\n```\n\n### 1.3 条件变量\n\n\n### 1.4 临界区\n\n\n参考：  \nhttp://blog.csdn.net/hiflower/article/details/2195350  \nhttp://blog.163.com/helloworld_zhouli/blog/static/2033711212012240502579/  \n\n\n","source":"_posts/自旋锁SpinLock.md","raw":"---\ntitle: 自旋锁SpinLock\ndate: 2017-04-03 16:34:11\ntags:\n---\n\n## 常见的锁机制\nPosix Threads（Pthreads）是在多核平台中进行多线程并行编程常用的API。它也提供了多种锁机制来实现多个线程对临界区的互斥访问，锁机制是实现线程同步的一种手段，另外一种手段是barrier机制，可以实现内存区域的同步。  \nPthreads库提供乐如下几种锁：  \n\n* mutex（互斥量）\n* Spin lock（自旋锁）\n* conditional variable（条件变量）\n* read/write lock（读写锁）\n\n### 1.1 mutex\nmutex属于sleep-waiting类型的锁，也就是说，当线程1想要锁住mutex进入临界区，那么如果mutex当前被其他线程持有，线程1就会进入阻塞状态（blocking），CPU核心会进行上下文切换将该线程放入等待队列，并开始运行其他线程。  \nPthread提供的mutex操作API如下：  \n```\npthread_mutex_lock (pthread_mutex_t *mutex);\npthread_mutex_trylock (pthread_mutex_t *mutex);\npthread_mutex_unlock (pthread_mutex_t *mutex);\n```\n\n### 1.2 spin lock\n自旋锁是一种busy-waiting类型的锁，也就是说，当线程2想要获取某个自旋锁时，如果当前该锁被其他线程持有，那么线程2不会阻塞，而是一直在当前CPU核心上进行忙等待并不断询问该锁是否被释放，直到获取为止。  \n由于自旋锁是忙等待，不会引起调用者被切换，这样一旦锁变为可用状态，可以立刻获取到，因此自旋锁的效率要比普通的互斥锁高。但它也有一些不足之处：  \n* 自旋锁等待过程中会一直占用CPU，这样如果短时间内不能获取到锁，那么CPU就在空转，使得CPU利用率降低。\n* 使用过程中也可能出现死锁。\n因此，自旋锁的适用场景是：锁的使用者持有锁的时间比较短，很快就会释放。否则，不适合使用自旋锁。  \nPthread提供的spin lock操作API如下：  \n```\npthread_spin_lock (pthread_spinlock_t *lock);\npthread_spin_trylock (pthread_spinlock_t *lock);\npthread_spin_unlock (pthread_spinlock_t *lock);\n```\n\n### 1.3 条件变量\n\n\n### 1.4 临界区\n\n\n参考：  \nhttp://blog.csdn.net/hiflower/article/details/2195350  \nhttp://blog.163.com/helloworld_zhouli/blog/static/2033711212012240502579/  \n\n\n","slug":"自旋锁SpinLock","published":1,"updated":"2017-04-04T11:56:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj17r3ahu000dpvs6pajc7lzj","content":"<h2 id=\"常见的锁机制\"><a href=\"#常见的锁机制\" class=\"headerlink\" title=\"常见的锁机制\"></a>常见的锁机制</h2><p>Posix Threads（Pthreads）是在多核平台中进行多线程并行编程常用的API。它也提供了多种锁机制来实现多个线程对临界区的互斥访问，锁机制是实现线程同步的一种手段，另外一种手段是barrier机制，可以实现内存区域的同步。<br>Pthreads库提供乐如下几种锁：  </p>\n<ul>\n<li>mutex（互斥量）</li>\n<li>Spin lock（自旋锁）</li>\n<li>conditional variable（条件变量）</li>\n<li>read/write lock（读写锁）</li>\n</ul>\n<h3 id=\"1-1-mutex\"><a href=\"#1-1-mutex\" class=\"headerlink\" title=\"1.1 mutex\"></a>1.1 mutex</h3><p>mutex属于sleep-waiting类型的锁，也就是说，当线程1想要锁住mutex进入临界区，那么如果mutex当前被其他线程持有，线程1就会进入阻塞状态（blocking），CPU核心会进行上下文切换将该线程放入等待队列，并开始运行其他线程。<br>Pthread提供的mutex操作API如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pthread_mutex_lock (pthread_mutex_t *mutex);</div><div class=\"line\">pthread_mutex_trylock (pthread_mutex_t *mutex);</div><div class=\"line\">pthread_mutex_unlock (pthread_mutex_t *mutex);</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-2-spin-lock\"><a href=\"#1-2-spin-lock\" class=\"headerlink\" title=\"1.2 spin lock\"></a>1.2 spin lock</h3><p>自旋锁是一种busy-waiting类型的锁，也就是说，当线程2想要获取某个自旋锁时，如果当前该锁被其他线程持有，那么线程2不会阻塞，而是一直在当前CPU核心上进行忙等待并不断询问该锁是否被释放，直到获取为止。<br>由于自旋锁是忙等待，不会引起调用者被切换，这样一旦锁变为可用状态，可以立刻获取到，因此自旋锁的效率要比普通的互斥锁高。但它也有一些不足之处：  </p>\n<ul>\n<li>自旋锁等待过程中会一直占用CPU，这样如果短时间内不能获取到锁，那么CPU就在空转，使得CPU利用率降低。</li>\n<li>使用过程中也可能出现死锁。<br>因此，自旋锁的适用场景是：锁的使用者持有锁的时间比较短，很快就会释放。否则，不适合使用自旋锁。<br>Pthread提供的spin lock操作API如下：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pthread_spin_lock (pthread_spinlock_t *lock);</div><div class=\"line\">pthread_spin_trylock (pthread_spinlock_t *lock);</div><div class=\"line\">pthread_spin_unlock (pthread_spinlock_t *lock);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"1-3-条件变量\"><a href=\"#1-3-条件变量\" class=\"headerlink\" title=\"1.3 条件变量\"></a>1.3 条件变量</h3><h3 id=\"1-4-临界区\"><a href=\"#1-4-临界区\" class=\"headerlink\" title=\"1.4 临界区\"></a>1.4 临界区</h3><p>参考：<br><a href=\"http://blog.csdn.net/hiflower/article/details/2195350\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/hiflower/article/details/2195350</a><br><a href=\"http://blog.163.com/helloworld_zhouli/blog/static/2033711212012240502579/\" target=\"_blank\" rel=\"external\">http://blog.163.com/helloworld_zhouli/blog/static/2033711212012240502579/</a>  </p>\n","excerpt":"","more":"<h2 id=\"常见的锁机制\"><a href=\"#常见的锁机制\" class=\"headerlink\" title=\"常见的锁机制\"></a>常见的锁机制</h2><p>Posix Threads（Pthreads）是在多核平台中进行多线程并行编程常用的API。它也提供了多种锁机制来实现多个线程对临界区的互斥访问，锁机制是实现线程同步的一种手段，另外一种手段是barrier机制，可以实现内存区域的同步。<br>Pthreads库提供乐如下几种锁：  </p>\n<ul>\n<li>mutex（互斥量）</li>\n<li>Spin lock（自旋锁）</li>\n<li>conditional variable（条件变量）</li>\n<li>read/write lock（读写锁）</li>\n</ul>\n<h3 id=\"1-1-mutex\"><a href=\"#1-1-mutex\" class=\"headerlink\" title=\"1.1 mutex\"></a>1.1 mutex</h3><p>mutex属于sleep-waiting类型的锁，也就是说，当线程1想要锁住mutex进入临界区，那么如果mutex当前被其他线程持有，线程1就会进入阻塞状态（blocking），CPU核心会进行上下文切换将该线程放入等待队列，并开始运行其他线程。<br>Pthread提供的mutex操作API如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pthread_mutex_lock (pthread_mutex_t *mutex);</div><div class=\"line\">pthread_mutex_trylock (pthread_mutex_t *mutex);</div><div class=\"line\">pthread_mutex_unlock (pthread_mutex_t *mutex);</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-2-spin-lock\"><a href=\"#1-2-spin-lock\" class=\"headerlink\" title=\"1.2 spin lock\"></a>1.2 spin lock</h3><p>自旋锁是一种busy-waiting类型的锁，也就是说，当线程2想要获取某个自旋锁时，如果当前该锁被其他线程持有，那么线程2不会阻塞，而是一直在当前CPU核心上进行忙等待并不断询问该锁是否被释放，直到获取为止。<br>由于自旋锁是忙等待，不会引起调用者被切换，这样一旦锁变为可用状态，可以立刻获取到，因此自旋锁的效率要比普通的互斥锁高。但它也有一些不足之处：  </p>\n<ul>\n<li>自旋锁等待过程中会一直占用CPU，这样如果短时间内不能获取到锁，那么CPU就在空转，使得CPU利用率降低。</li>\n<li>使用过程中也可能出现死锁。<br>因此，自旋锁的适用场景是：锁的使用者持有锁的时间比较短，很快就会释放。否则，不适合使用自旋锁。<br>Pthread提供的spin lock操作API如下：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pthread_spin_lock (pthread_spinlock_t *lock);</div><div class=\"line\">pthread_spin_trylock (pthread_spinlock_t *lock);</div><div class=\"line\">pthread_spin_unlock (pthread_spinlock_t *lock);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"1-3-条件变量\"><a href=\"#1-3-条件变量\" class=\"headerlink\" title=\"1.3 条件变量\"></a>1.3 条件变量</h3><h3 id=\"1-4-临界区\"><a href=\"#1-4-临界区\" class=\"headerlink\" title=\"1.4 临界区\"></a>1.4 临界区</h3><p>参考：<br><a href=\"http://blog.csdn.net/hiflower/article/details/2195350\">http://blog.csdn.net/hiflower/article/details/2195350</a><br><a href=\"http://blog.163.com/helloworld_zhouli/blog/static/2033711212012240502579/\">http://blog.163.com/helloworld_zhouli/blog/static/2033711212012240502579/</a>  </p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj17r3agw0000pvs6uto8rgsz","tag_id":"cj17r3ai5000epvs65rejryem","_id":"cj17r3aj2000opvs6bc00mood"},{"post_id":"cj17r3ahb0003pvs6mt37s58c","tag_id":"cj17r3aik000fpvs6dkusmnnw","_id":"cj17r3aj4000ppvs6v73smwhj"},{"post_id":"cj17r3ahb0003pvs6mt37s58c","tag_id":"cj17r3ail000gpvs6xqbeyzjx","_id":"cj17r3aj4000qpvs6ss959qz4"},{"post_id":"cj17r3ahi0006pvs6az4667fc","tag_id":"cj17r3ail000hpvs6qz29iee8","_id":"cj17r3aj4000rpvs6418itrq3"},{"post_id":"cj17r3ahl0008pvs6a9odbjjm","tag_id":"cj17r3ail000ipvs60cqe3e3b","_id":"cj17r3aj4000spvs6t91fdgss"},{"post_id":"cj17r3ahl0008pvs6a9odbjjm","tag_id":"cj17r3aim000jpvs65g72gw6h","_id":"cj17r3aj4000tpvs64qn4f4e0"},{"post_id":"cj17r3ahm0009pvs6aofz4k72","tag_id":"cj17r3ain000kpvs6xiqi4j50","_id":"cj17r3aj4000upvs6il1kkn5u"},{"post_id":"cj17r3aho000apvs6wy3rwwex","tag_id":"cj17r3ain000lpvs6nfhqe9eo","_id":"cj17r3aj5000vpvs6a7kgvi4y"},{"post_id":"cj17r3ahq000bpvs67t3ahjmu","tag_id":"cj17r3ain000mpvs6qpu1hbym","_id":"cj17r3aj5000wpvs6kotd7o1h"},{"post_id":"cj17r3ahr000cpvs6mbuomf1u","tag_id":"cj17r3ain000npvs6hc8a31us","_id":"cj17r3aj5000xpvs63ok9dqqs"}],"Tag":[{"name":"B+tree","_id":"cj17r3ai5000epvs65rejryem"},{"name":"shell","_id":"cj17r3aik000fpvs6dkusmnnw"},{"name":"Linux","_id":"cj17r3ail000gpvs6xqbeyzjx"},{"name":"Paxos","_id":"cj17r3ail000hpvs6qz29iee8"},{"name":"sublime text","_id":"cj17r3ail000ipvs60cqe3e3b"},{"name":"快捷键","_id":"cj17r3aim000jpvs65g72gw6h"},{"name":"hexo","_id":"cj17r3ain000kpvs6xiqi4j50"},{"name":"C++","_id":"cj17r3ain000lpvs6nfhqe9eo"},{"name":"隔离级别","_id":"cj17r3ain000mpvs6qpu1hbym"},{"name":"time","_id":"cj17r3ain000npvs6hc8a31us"}]}}